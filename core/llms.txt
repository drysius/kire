// Combined source for kire

// --- From: core/src/compiler.ts ---
import type { Kire } from "./kire";
import type { CompilerContext, Node } from "./types";

export class Compiler {
    private preBuffer: string[] = [];
    private resBuffer: string[] = [];
    private posBuffer: string[] = [];
    // Removed gPreBuffer and gPosBuffer

    private usedDirectives: Set<string> = new Set();

    constructor(private kire: Kire) {}

    public async compile(nodes: Node[]): Promise<string> {
        this.preBuffer = [];
        this.resBuffer = [];
        this.posBuffer = [];
        // Removed gPreBuffer and gPosBuffer init
        this.usedDirectives.clear();

        // Compile the root nodes
        await this.compileNodes(nodes);

        // gPre and gPos are now collected at runtime via generated code
        const pre = this.preBuffer.join("\n");
        const res = this.resBuffer.join("\n");
        const pos = this.posBuffer.join("\n");

        // Main function body code
        const code = `with($ctx) { \n${pre}\n${res}\n${pos}\nreturn $ctx;\n }`;

        return code;
    }

    private async compileNodes(nodes: Node[]) {
        let i = 0;
        while (i < nodes.length) {
            const node = nodes[i]!;
            if (node.type === "text") {
                if (node.content) {
                    this.resBuffer.push(
                        `$ctx['~res'] += ${JSON.stringify(node.content)};`,
                    );
                }
            } else if (node.type === "variable") {
                if (node.content) {
                    if (node.raw) {
                        this.resBuffer.push(
                            `$ctx['~res'] += (${node.content});`,
                        );
                    } else {
                        this.resBuffer.push(
                            `$ctx['~res'] += $ctx.$escape(${node.content});`,
                        );
                    }
                }
            } else if (node.type === "directive") {
                await this.processDirective(node);
            }
            i++;
        }
    }

    private async processDirective(node: Node) {
        const name = node.name;
        if (!name) return;

        // Check if directive exists in Kire instance
        const directive = this.kire.getDirective(name);

        if (!directive) {
            // Handle unknown directive
            console.warn(`Directive @${name} not found.`);
            return;
        }

        const self = this;
        const compiler: CompilerContext = {
            kire:this.kire,
            param: (key: string | number) => {
                if (typeof key === "number") {
                    return node.args?.[key];
                }
                if (directive.params && node.args) {
                    const index = directive.params.findIndex(
                        (p) => p.split(":")[0] === key,
                    );
                    if (index !== -1) return node.args[index];
                }
                return undefined;
            },
            children: node.children,
            parents: node.related, // 'parents' in user logic map to 'related' nodes from parser
            set: async (nodes: Node[]) => {
                if (!nodes) return;
                await this.compileNodes(nodes);
            },
            render: async (content: string) => {
                // This needs to return the object {code, gPre, gPos}
                // But compile expects string for now.
                return (await this.kire.compile(content)); 
            },
            resolve: (path: string) => {
                return this.kire.resolvePath(path);
            },
            func: (code: string) => {
                return `async function($ctx) { ${code} }`;
            },
            pre: (code: string) => {
                this.preBuffer.push(code);
            },
            res: (content: string) => {
                const escaped = content
                    .replace(/\\/g, "\\\\")
                    .replace(/`/g, "\\`")
                    .replace(/\${/g, "\\${ ");
                this.resBuffer.push(`$ctx.res(\`${escaped}\`);`);
            },
            raw: (code: string) => {
                this.resBuffer.push(code);
            },
            pos: (code: string) => {
                this.posBuffer.push(code);
            },
            $pre: (code: string) => {
                this.resBuffer.push(`$ctx['~$pre'].push(async ($ctx) => { with($ctx) { ${code} } });`);
            },
            $pos: (code: string) => {
                this.resBuffer.push(`$ctx['~$pos'].push(async ($ctx) => { with($ctx) { ${code} } });`);
            },
            error: (msg: string) => {
                throw new Error(`Error in directive @${name}: ${msg}`);
            },
            get '~res'() { return self.resBuffer.join('\n'); },
            get '~pre'() { return self.preBuffer; },
            get '~pos'() { return self.posBuffer; },
        };

        await directive.onCall(compiler);
    }
}

// --- From: core/src/types.ts ---
import type { Kire } from "./kire";

export type KireCache<T = any> = Map<string, T>;

export interface KireConfig {
	globals?: Record<string, any>;
	// Add other config options as needed
}

export interface IParser {
	parse(): Node[];
}
export type IParserConstructor = new (template: string, kire: Kire) => IParser;

export interface ICompiler {
	compile(nodes: Node[]): Promise<string>;
}
export type ICompilerConstructor = new (kire: Kire) => ICompiler;

/**
 * Options for configuring the Kire instance.
 */
export interface KireOptions {
	/**
	 * The root directory for resolving file paths. Defaults to "./".
	 */
	root?: string;
	/**
	 * Whether to run in production mode (enables caching). Defaults to true.
	 */
	production?: boolean;
	/**
	 * Custom file resolver function.
	 */
	resolver?: (filename: string) => Promise<string>;
	/**
	 * Path aliases for imports (e.g., { "~/": "./src/" }).
	 */
	alias?: Record<string, string>;
	/**
	 * Default file extension for templates. Defaults to "kire".
	 */
	extension?: string;
	/**
	 * Whether to load default directives. Defaults to true.
	 */
	directives?: boolean;
	/**
	 * List of plugins to load.
	 */
	plugins?: (KirePlugin | [KirePlugin, any])[];
	/**
	 * Custom engine components.
	 */
	engine?: {
		parser?: IParserConstructor;
		compiler?: ICompilerConstructor;
	};
	/**
	 * Name of the variable exposing locals in the template. Defaults to "it".
	 */
	varLocals?: string;
	/**
	 * Whether to expose locals as a specific variable (defined by varLocals).
	 */
	exposeLocals?: boolean;
}

/**
 * The runtime context object ($ctx) used during template execution.
 */
export interface KireContext {
	/**
	 * The accumulated string buffer for the local scope's output.
	 */
	'~res': string;
	
	/**
	 * A global buffer for code or functions to be executed *before* the main entry point's rendering logic.
	 */
	'~$pre': Function[];
	
	/**
	 * A global buffer for code or functions to be executed *after* the main entry point's rendering logic.
	 */
	'~$pos': Function[];

	/**
	 * Appends content to the current output buffer (~res).
	 * @param str The content to append.
	 */
	res(str: string): void;

	/**
	 * Returns the current output buffer content.
	 */
	$res(): string;

	/**
	 * Resolves a file path relative to the project root and aliases.
	 */
	$resolve(path: string): string;

	/**
	 * Creates a new isolation scope for capturing output (e.g. for slots or defines).
	 * @param func The function to execute within the merged scope.
	 */
	$merge(func: (ctx: KireContext) => Promise<void>): Promise<void>;

	/**
	 * Imports and renders another .kire template.
	 */
	$require?(path: string, locals?: Record<string, any>): Promise<string | null>;

	/**
	 * Helper for MD5 hashing.
	 */
	$md5?(str: string): string;

	/**
	 * Helper for HTML escaping.
	 */
	$escape?(unsafe: any): string;

	/**
	 * Arbitrary locals and globals.
	 */
	[key: string]: any;
}

/**
 * The context object passed to directives during compilation.
 * Renamed from KireContext to CompilerContext to avoid confusion with the runtime context.
 */
export interface CompilerContext {
	/**
	 * Kire instance
	 */
	kire:Kire;
	/**
	 * Retrieves a parameter passed to the directive.
	 * @param name The name or index of the parameter.
	 */
	param(name: string | number): any;
	
	/**
	 * Compiles a string of Kire template content.
	 * @param content The template string to compile.
	 * @returns The compiled function code as a string.
	 */
	render(content: string): Promise<string>;

	/**
	 * Wraps the provided code in an async function definition.
	 * @param code The function body.
	 */
	func(code: string): string;
	
	// --- Local Function Scope ---

	/**
	 * Pushes code to be executed *before* the local rendering result accumulation begins.
	 * Useful for variable declarations or setup logic.
	 */
	pre(code: string): void;

	/**
	 * Appends code that adds content to the local result buffer (~res).
	 * @param content The raw content to append.
	 */
	res(content: string): void;

	/**
	 * Pushes raw code directly into the main execution flow of the compiled function.
	 * @param code The JavaScript code to inject.
	 */
	raw(code: string): void;

	/**
	 * Pushes code to be executed *after* the local rendering result accumulation ends.
	 * Useful for post-processing the result (replacements) or cleanup.
	 */
	pos(code: string): void;
	
	// --- Global Scope (Main File) ---

	/**
	 * Pushes code to the global pre-processing stack (~$pre).
	 * These functions run before the main entry point's rendering logic.
	 */
	$pre(code: string): void;

	/**
	 * Pushes code to the global post-processing stack (~$pos).
	 * These functions run after the main entry point's rendering logic has finished.
	 */
	$pos(code: string): void;

	/**
	 * Throws a compilation error with a specific message.
	 */
	error(message: string): void;

	/**
	 * Resolves a file path relative to the project root and aliases.
	 */
	resolve(path: string): string;

	// --- Compiler State Inspection ---
	// These properties allow checking the current state of the compilation buffers.

	/**
	 * The current content of the local result buffer code.
	 */
	'~res'?: string;

	/**
	 * The current content of the local pre-processing buffer code.
	 */
	'~pre'?: string[]; // Changed to string[] because it's a buffer of code lines in the compiler

	/**
	 * The current content of the local post-processing buffer code.
	 */
	'~pos'?: string[]; // Changed to string[] because it's a buffer of code lines in the compiler

	/**
	 * The current content of the global pre-processing buffer code.
	 */
	'~$pre'?: string[];

	/**
	 * The current content of the global post-processing buffer code.
	 */
	'~$pos'?: string[];

	// --- Nesting & Structure ---

	/**
	 * The children nodes of the current directive (for block directives).
	 */
	children?: Node[];

	/**
	 * Related nodes, such as chained directives (e.g., elseif, else).
	 */
	parents?: Node[]; 

	/**
	 * Compiles and processes a set of nodes, appending their logic to the current flow.
	 */
	set(nodes: Node[]): Promise<void>;
}

/**
 * Context provided to element handlers (middleware) for manipulating HTML output.
 */
export interface KireElementContext extends KireContext {
	/**
	 * The current global HTML content string. This is mutable and represents the state of the document.
	 */
	content: string;
	
	/**
	 * Typed $ctx context use key of $ctx context with you type
	 * @param key 
	 */
	$typed<T>(key:string): T;

	/**
	 * Details about the specific HTML element being processed.
	 */
	element: {
		/**
		 * The tag name of the element (e.g., "div", "custom-tag").
		 */
		tagName: string;
		/**
		 * A map of the element's attributes.
		 */
		attributes: Record<string, string>;
		/**
		 * The inner HTML content of the element.
		 */
		inner: string;
		/**
		 * The full outer HTML of the element (including tags).
		 */
		outer: string;
	};

	/**
	 * Updates the entire global HTML content.
	 * @param newContent The new HTML content string.
	 */
	update(newContent: string): void;

	/**
	 * Replaces the current element's outer HTML in the global content.
	 * @param replacement The string to replace the element with.
	 */
	replace(replacement: string): void;

	/**
	 * Replaces the current element's outer HTML in the global content.
	 * @param replacement The string to replace the element with.
	 */
	replaceElement(replacement: string): void;

	/**
	 * Replaces the current element's inner HTML in the global content.
	 * @param replacement The string to replace the inner content with.
	 */
	replaceContent(replacement: string): void;
}

export type KireElementHandler = (
	ctx: KireElementContext,
) => Promise<void> | void;

export interface KireElementOptions {
	/**
	 * Whether the element is a void element (self-closing, no closing tag).
	 */
	void?: boolean;
}

export interface ElementDefinition {
	name: string | RegExp;
	description?: string;
	example?: string;
	void?: boolean;
	onCall: KireElementHandler;
}

/**
 * Definition of a custom directive.
 */
export interface DirectiveDefinition {
	/**
	 * The name of the directive (used as @name).
	 */
	name: string;
	/**
	 * Parameter definitions (e.g., ['filepath:string']).
	 */
	params?: string[]; 
	/**
	 * Whether this directive accepts a block ending with @end.
	 * If "auto", the parser checks for a matching @end tag to decide.
	 */
	children?: boolean | "auto"; 
	/**
	 * Should the children be treated as raw text instead of parsed nodes?
	 */
	childrenRaw?: boolean; 
	/**
	 * Sub-directives associated with this one (e.g., elseif, else for @if).
	 */
	parents?: DirectiveDefinition[]; 
	/**
	 * Function called when the directive is encountered during compilation.
	 */
	onCall: (compiler: CompilerContext) => void | Promise<void>;
	/**
	 * Function called once per compilation when the directive is first used.
	 */
	onInit?: (ctx: KireContext) => void | Promise<void>;
	
	description?: string;
	example?: string;
	/**
	 * The type of logic this directive handles (css, js, or html structure).
	 */
	type?: "css" | "js" | "html";
}

export interface KireSchematic {
	package: string;
	repository?: string | { type: string; url: string };
	version?: string;
	directives?: DirectiveDefinition[];
	elements?: ElementDefinition[];
	globals?: Record<string, any>;
}

export interface KirePlugin<Options extends object | undefined = {}> {
	name: string;
	sort?: number;
	options: Options;
	load(kire: Kire, opts?: Options): void;
}

// AST Types
export type NodeType = "text" | "variable" | "directive";

export interface SourceLocation {
	line: number;
	column: number;
}

export interface Node {
	type: NodeType;
	content?: string;
	name?: string; // For directives
	args?: any[]; // For directives
	start?: number;
	end?: number;
	loc?: {
		start: SourceLocation;
		end: SourceLocation;
	};
	children?: Node[]; // Inner content
	related?: Node[]; // For 'parents' (elseif, etc)
	raw?: boolean;
}


// --- From: core/src/parser.ts ---
import type { Kire } from "./kire";
import type { DirectiveDefinition, Node } from "./types";

export class Parser {
    private cursor = 0;
    private stack: Node[] = [];
    private rootChildren: Node[] = [];
    public line = 1;
    public column = 1;

    constructor(
        private template: string,
        private kire: Kire,
    ) {}

    public parse(): Node[] {
        this.cursor = 0;
        this.stack = [];
        this.rootChildren = [];

        while (this.cursor < this.template.length) {
            const remaining = this.template.slice(this.cursor);
            //console.log('PARSER:', {
            //  cursor: this.cursor,
            //  remaining: remaining.slice(0, 30),
            //  stack: this.stack.map(s => s.name)
            //});

            // Check for raw interpolation {{{ ... }}}
            const rawInterpolationMatch = remaining.match(/^\{\{\{([\s\S]*?)\}\}\}/);
            if (rawInterpolationMatch) {
                const content = rawInterpolationMatch[0];
                this.addNode({
                    type: "variable",
                    content: rawInterpolationMatch[1]?.trim(),
                    raw: true,
                    start: this.cursor,
                    end: this.cursor + content.length,
                    loc: this.getLoc(content),
                });
                this.advance(content);
                continue;
            }

            // Check for interpolation {{ ... }}
            const interpolationMatch = remaining.match(/^\{\{([\s\S]*?)\}\}/);
            if (interpolationMatch) {
                const content = interpolationMatch[0];
                this.addNode({
                    type: "variable",
                    content: interpolationMatch[1]?.trim(),
                    raw: false,
                    start: this.cursor,
                    end: this.cursor + content.length,
                    loc: this.getLoc(content),
                });
                this.advance(content);
                continue;
            }

            // Check for escaped directive @@
            if (remaining.startsWith("@@")) {
                this.addNode({
                    type: "text",
                    content: "@",
                    start: this.cursor,
                    end: this.cursor + 2,
                    loc: this.getLoc("@@"),
                });
                this.advance("@@");
                continue;
            }

            // Check for directive @name(...) or @name without parentheses
            // Use longest matching directive name first
            const directiveStartMatch = remaining.match(/^@([a-zA-Z0-9_]+)/);
            if (directiveStartMatch) {
                let [fullMatch, name] = directiveStartMatch;

                // 1. First, check if this is a sub-directive of any active parent in the stack.
                // This takes precedence over global directives and prefix matching in global scope.
                // We iterate backwards to find the nearest parent that accepts this as a sub-directive.
                let isSubDirective = false;
                let subDef: DirectiveDefinition | undefined;
                let parentNode: Node | undefined;
                let validName = name;
                let foundDirective: DirectiveDefinition | undefined;

                if (this.stack.length > 0) {
                    for (let i = this.stack.length - 1; i >= 0; i--) {
                        const currentParent = this.stack[i];
                        const parentDef = this.kire.getDirective(currentParent?.name as string);

                        if (parentDef?.parents) {
                             // Try to match name against parents
                             // Sort by length to support longest prefix if needed? 
                             // Usually sub-directives are exact matches or strict aliases.
                             // But if we support @elseA (unlikely for strict keywords), we might need prefix logic here too.
                             // Let's assume strict match for sub-directives for now, or prefix if needed.
                             
                             const candidates = parentDef.parents.filter(p => name.startsWith(p.name));
                             candidates.sort((a, b) => b.name.length - a.name.length);
                             
                             if (candidates.length > 0) {
                                 const p = candidates[0];
                                 // Check if we found a valid prefix match
                                 // Update validName
                                 validName = p.name;
                                 subDef = p;
                                 parentNode = currentParent;
                                 isSubDirective = true;
                                 
                                 // Since we found a match at stack[i], we must close all blocks above it (siblings)
                                 // e.g. [if, elseif]. Match at [if]. Close [elseif].
                                 while (this.stack.length > i + 1) {
                                     this.stack.pop();
                                 }
                                 break;
                             }
                        }
                    }
                }

                // 2. If not a sub-directive, check global directives with prefix matching
                if (!isSubDirective) {
                    foundDirective = this.kire.getDirective(name);
                    
                    if (!foundDirective) {
                         const allDirectives = Array.from(this.kire.$directives.values()).sort((a, b) => b.name.length - a.name.length);
                         for (const d of allDirectives) {
                             if (name.startsWith(d.name)) {
                                 validName = d.name;
                                 foundDirective = d;
                                 break;
                             }
                         }
                    }
                }

                // Update fullMatch if we matched a shorter name (prefix)
                if (validName !== name) {
                     name = validName;
                     fullMatch = "@" + name;
                } else if (!foundDirective && !isSubDirective && name === "end") {
                     // Keep "end"
                } else if (!isSubDirective && !foundDirective) {
                     // Try exact fetch again just in case
                     foundDirective = this.kire.getDirective(name);
                }

                //console.log('FOUND DIRECTIVE:', { name, fullMatch, stack: this.stack.map(s => s.name) });

                // Check if it has arguments
                let argsStr: string | undefined;
                let argsEndIndex = fullMatch.length;

                // Verifica se tem parênteses APENAS se o próximo caractere for '('
                if (remaining[fullMatch.length] === "(") {
                    // Parse arguments with balanced parentheses
                    let depth = 1;
                    let i = fullMatch.length + 1;
                    let inQuote = false;
                    let quoteChar = "";

                    while (i < remaining.length && depth > 0) {
                        const char = remaining[i];
                        if (
                            (char === '"' || char === "'") &&
                            (i === 0 || remaining[i - 1] !== "\\")
                        ) {
                            if (inQuote && char === quoteChar) {
                                inQuote = false;
                            } else if (!inQuote) {
                                inQuote = true;
                                quoteChar = char;
                            }
                        }

                        if (!inQuote) {
                            if (char === "(") depth++;
                            else if (char === ")") depth--;
                        }
                        i++;
                    }

                    if (depth === 0) {
                        argsStr = remaining.slice(fullMatch.length + 1, i - 1);
                        argsEndIndex = i;
                    }
                }

                if (name === "end") {
                    //console.log('HANDLING END DIRECTIVE');
                    this.handleEndDirective();
                    this.advance(remaining.slice(0, argsEndIndex));
                    continue;
                }

                // directiveDef is already found as foundDirective
                const directiveDef = foundDirective;
                //console.log('DIRECTIVE DEF:', { name, directiveDef });

                if (isSubDirective && subDef && parentNode) {
                            //console.log('FOUND SUB DIRECTIVE! Processing:', name);
                            const fullContent = remaining.slice(0, argsEndIndex);
                            this.handleSubDirective(
                                name!,
                                argsStr,
                                fullContent,
                                parentNode,
                                subDef,
                                this.getLoc(fullContent),
                            );
                            this.advance(fullContent);
                            continue;
                }

                // If not a registered directive and not a sub-directive, treat as text
                if (!directiveDef && !isSubDirective) {
                    //console.log('TREATING AS TEXT:', name);
                    this.addNode({
                        type: "text",
                        content: fullMatch,
                        start: this.cursor,
                        end: this.cursor + fullMatch.length,
                        loc: this.getLoc(fullMatch),
                    });
                    this.advance(fullMatch);
                    continue;
                }

                const args = argsStr ? this.parseArgs(argsStr) : [];
                const fullContent = remaining.slice(0, argsEndIndex);

                const node: Node = {
                    type: "directive",
                    name: name,
                    args: args,
                    start: this.cursor,
                    end: this.cursor + argsEndIndex,
                    loc: this.getLoc(fullContent),
                    children: [],
                    related: [],
                };

                //console.log('ADDING DIRECTIVE NODE:', node);
                this.addNode(node);

                if (directiveDef?.children) {
                    let shouldHaveChildren = true;
                    if (directiveDef.children === "auto") {
                        // Check if there is a matching @end for this directive at this level
                        // Simple heuristic: search for @end, counting nested directives of same name?
                        // Actually, just checking if an @end exists before end of string might be enough for basic cases,
                        // but correct handling requires lookahead balancing.
                        
                        // We need to look ahead to see if this directive is closed.
                        // If we find an @end that corresponds to this level, treat as block.
                        // If not, treat as void.
                        
                        // BUT, if we just assume "auto" means "block if @end found",
                        // we need to be careful about nested blocks.
                        
                        // Heuristic: Scan ahead. 
                        // Count open same-name directives? No, generic @end closes any block.
                        // So we scan for @directive vs @end.
                        
                        let balance = 1;
                        let lookaheadCursor = argsEndIndex; // Relative to remaining
                        let foundEnd = false;
                        
                        const subRemaining = remaining.slice(lookaheadCursor);
                        
                        // Regex to find directives
                        const tagRegex = /@([a-zA-Z0-9_]+)/g;
                        let match;
                        
                        while ((match = tagRegex.exec(subRemaining)) !== null) {
                            const tagName = match[1];
                            if (tagName === "end") {
                                balance--;
                                if (balance === 0) {
                                    foundEnd = true;
                                    break;
                                }
                            } else {
                                // Check if this tag is a block directive
                                const d = this.kire.getDirective(tagName);
                                // If we don't know it, ignore? Or treat as text?
                                // If it IS a block directive, increment balance.
                                if (d?.children) {
                                    balance++;
                                }
                            }
                        }
                        
                        shouldHaveChildren = foundEnd;
                    }

                    if (shouldHaveChildren) {
                        if (directiveDef.childrenRaw) {
                            this.stack.push(node);

                            const contentStart = this.cursor + argsEndIndex;
                            const remainingTemplate = this.template.slice(contentStart);

                            // Update cursor temporarily to calculate correct loc for raw content
                            // We need to advance virtually to get correct start loc for content
                            const directiveLoc = this.getLoc(fullContent);
                            // Actually we can't easily use getLoc because it depends on this.line/column which haven't advanced yet.
                            // We must advance after adding directive node but BEFORE processing raw content.
                            // Wait, we addNode(directive) then advance(directive) then process content?
                            // The current logic: addNode -> stack push -> then advance? No.
                            
                            // Current flow:
                            // 1. addNode(directive)
                            // 2. if childrenRaw:
                            //    stack.push
                            //    find end
                            //    addNode(text)
                            //    stack.pop
                            //    advance(directive + text + end)
                            
                            // This makes `this.line` stale for the text node inside childrenRaw block.
                            // We need to calculate text node loc relative to where directive ends.
                            
                            // Find closing @end with word boundary check
                            const endMatch = remainingTemplate.match(/@end(?![a-zA-Z0-9_])/);

                            if (endMatch) {
                                const content = remainingTemplate.slice(0, endMatch.index);
                                
                                // Calculate loc for the inner content
                                // Start is end of directive
                                const startLoc = directiveLoc.end;
                                // End is calculated from content
                                const contentLines = content.split('\n');
                                let endLine = startLoc.line;
                                let endCol = startLoc.column;
                                if (contentLines.length > 1) {
                                    endLine += contentLines.length - 1;
                                    endCol = (contentLines[contentLines.length - 1]?.length || 0) + 1;
                                } else {
                                    endCol += content.length;
                                }

                                // Add text node
                                this.addNode({
                                    type: "text",
                                    content: content,
                                    start: contentStart,
                                    end: contentStart + content.length,
                                    loc: { start: startLoc, end: { line: endLine, column: endCol } }
                                });

                                this.stack.pop(); // Close immediately
                                this.advance(
                                    remaining.slice(0, argsEndIndex) + content + endMatch[0],
                                );
                                continue;
                            } else {
                                // No end tag found, consume rest
                                const content = remainingTemplate;
                                
                                this.addNode({
                                    type: "text",
                                    content: content,
                                    start: contentStart,
                                    end: this.template.length,
                                    // loc: ... (omitted for simplicity in error case)
                                });
                                this.stack.pop();
                                this.advance(remaining.slice(0, argsEndIndex) + content);
                                continue;
                            }
                        }
                        //console.log('PUSHING TO STACK:', name);
                        this.stack.push(node);
                    }
                }

                this.advance(remaining.slice(0, argsEndIndex));
                continue;
            }

            // Text
            const nextInterpolation = remaining.indexOf("{{");
            const nextDirective = remaining.indexOf("@");

            let nextIndex = -1;
            if (nextInterpolation !== -1 && nextDirective !== -1) {
                nextIndex = Math.min(nextInterpolation, nextDirective);
            } else if (nextInterpolation !== -1) {
                nextIndex = nextInterpolation;
            } else if (nextDirective !== -1) {
                nextIndex = nextDirective;
            }

            if (nextIndex === -1) {
                this.addNode({
                    type: "text",
                    content: remaining,
                    start: this.cursor,
                    end: this.template.length,
                    loc: this.getLoc(remaining),
                });
                this.advance(remaining);
            } else {
                if (nextIndex === 0) {
                    const char = remaining[0]!;
                    this.addNode({
                        type: "text",
                        content: char,
                        start: this.cursor,
                        end: this.cursor + 1,
                        loc: this.getLoc(char),
                    });
                    this.advance(char);
                } else {
                    const text = remaining.slice(0, nextIndex);
                    this.addNode({
                        type: "text",
                        content: text,
                        start: this.cursor,
                        end: this.cursor + text.length,
                        loc: this.getLoc(text),
                    });
                    this.advance(text);
                }
            }
        }

        //console.log('FINAL RESULT:', JSON.stringify(this.rootChildren, null, 2));
        return this.rootChildren;
    }

    private handleEndDirective() {
        //console.log('HANDLE END - Stack before:', this.stack.map(s => s.name));
        if (this.stack.length > 0) {
            const popped = this.stack.pop();
            
            // Check if the popped node was a sub-directive (related) of the current parent
            // If so, it means we closed the sub-directive (like @else), and thus we should close the parent (@if) too.
            // This is the default behavior for related directives (chains).
            if (this.stack.length > 0) {
                const parent = this.stack[this.stack.length - 1];
                if (parent?.related?.includes(popped!)) {
                    this.stack.pop(); // Close parent
                }
            }
        }
        //console.log('HANDLE END - Popped:', popped?.name);
        //console.log('HANDLE END - Stack after:', this.stack.map(s => s.name));
    }

    private handleSubDirective(
        name: string,
        argsStr: string | undefined,
        fullMatch: string,
        parentNode: Node,
        subDef: DirectiveDefinition,
        loc: any,
    ) {
        const args = argsStr ? this.parseArgs(argsStr) : [];

        const node: Node = {
            type: "directive",
            name: name,
            args: args,
            start: this.cursor,
            end: this.cursor + fullMatch.length,
            loc: loc,
            children: [],
            related: [],
        };

        // If the current top of stack is already a related node of the parent (e.g. we are in @elseif and found @else),
        // we need to close the current sibling (@elseif) before opening the new one (@else).
        // Use the parentNode passed in, which was found by searching the stack.
        if (this.stack.length > 0) {
            const currentTop = this.stack[this.stack.length - 1];
            // Check if currentTop is a sibling (i.e. it is in parentNode.related)
            if (parentNode.related?.includes(currentTop!)) {
                this.stack.pop();
            }
        }

        //console.log('HANDLING SUB DIRECTIVE:', {
        //  name,
        //  parent: parentNode.name,
        //  node,
        //  parentRelated: parentNode.related
        //});

        if (!parentNode.related) parentNode.related = [];
        parentNode.related.push(node);

        if (subDef.children) {
            //console.log('PUSHING SUB DIRECTIVE TO STACK:', name);
            this.stack.push(node);
        }
    }

    private getLoc(content: string) {
        const start = { line: this.line, column: this.column };
        const lines = content.split("\n");
        let endLine = this.line;
        let endColumn = this.column;

        if (lines.length > 1) {
            endLine += lines.length - 1;
            endColumn = (lines[lines.length - 1]?.length || 0) + 1;
        } else {
            endColumn += content.length;
        }

        return {
            start,
            end: { line: endLine, column: endColumn },
        };
    }

    private addNode(node: Node) {
        if (this.stack.length > 0) {
            const current = this.stack[this.stack.length - 1];
            if (current && !current.children) current.children = [];
            if (current?.children) {
                //console.log('ADDING TO CHILDREN of', current.name, ':', node.type, node.name || node.content);
                current.children.push(node);
            }
        } else {
            //console.log('ADDING TO ROOT:', node.type, node.name || node.content);
            this.rootChildren.push(node);
        }
    }

    private advance(str: string) {
        const lines = str.split("\n");
        if (lines.length > 1) {
            this.line += lines.length - 1;
            this.column = (lines[lines.length - 1]?.length || 0) + 1;
        } else {
            this.column += str.length;
        }
        this.cursor += str.length;
    }

    private parseArgs(argsStr: string): any[] {
        const args: any[] = [];
        let current = "";
        let inQuote = false;
        let quoteChar = "";
        let braceDepth = 0;
        let bracketDepth = 0;
        let parenDepth = 0;

        for (let i = 0; i < argsStr.length; i++) {
            const char = argsStr[i];

            // Handle quotes
            if (
                (char === '"' || char === "'") &&
                (i === 0 || argsStr[i - 1] !== "\\")
            ) {
                if (inQuote && char === quoteChar) {
                    inQuote = false;
                } else if (!inQuote) {
                    inQuote = true;
                    quoteChar = char;
                }
            }

            if (!inQuote) {
                if (char === "{") braceDepth++;
                else if (char === "}") braceDepth--;
                else if (char === "[") bracketDepth++;
                else if (char === "]") bracketDepth--;
                else if (char === "(") parenDepth++;
                else if (char === ")") parenDepth--;
            }

            if (
                char === "," &&
                !inQuote &&
                braceDepth === 0 &&
                bracketDepth === 0 &&
                parenDepth === 0
            ) {
                args.push(current.trim());
                current = "";
            } else {
                current += char;
            }
        }
        if (current) args.push(current.trim());

        return args.map((arg) => {
            if (
                (arg.startsWith('"') && arg.endsWith('"')) ||
                (arg.startsWith("'") && arg.endsWith("'"))
            ) {
                return arg.slice(1, -1);
            }
            if (arg === "true") return true;
            if (arg === "false") return false;
            if (!Number.isNaN(Number(arg))) return Number(arg);
            return arg;
        });
    }
}


// --- From: core/src/kire.ts ---
import { Compiler } from "./compiler";
import { KireDirectives } from "./directives";
import { Parser } from "./parser";
import type {
	DirectiveDefinition,
	ElementDefinition,
	ICompilerConstructor,
	IParserConstructor,
	KireCache,
	KireElementHandler,
	KireElementOptions,
	KireOptions,
	KirePlugin,
	KireSchematic,
} from "./types";
import { resolvePath } from "./utils/resolve";

export class Kire {
	public $directives: Map<string, DirectiveDefinition> = new Map();
	public $elements: Set<ElementDefinition> = new Set();
	public $globals: Map<string, any> = new Map();

	public root: string;
	public production: boolean;
	public $resolver: (filename: string) => Promise<string>;
	public $readdir?: (pattern: string) => Promise<string[]>;
	public alias: Record<string, string>;
	extension: string;
	public $files: Map<string, Function> = new Map();
	public $parser: IParserConstructor;
	public $compiler: ICompilerConstructor;
	public $var_locals: string;
	public $expose_locals: boolean;
	public $cache: Map<string, Map<string, any>> = new Map();

	public cacheClear() {
		this.$cache.clear();
		this.$files.clear();
	}

	public cached<T = any>(namespace: string): KireCache<T> {
		if (!this.$cache.has(namespace)) {
			this.$cache.set(namespace, new Map());
		}
		const store = this.$cache.get(namespace)!;
		return store;
	}

	constructor(options: KireOptions = {}) {
		this.root = options.root ?? "./";
		this.production = options.production ?? true;
		this.alias = options.alias ?? { "~/": this.root };
		this.extension = options.extension ?? "kire";
		this.$var_locals = options.varLocals ?? "it";
		this.$expose_locals = options.exposeLocals ?? true;

		this.$resolver =
			options.resolver ??
			(async (filename) => {
				throw new Error(`No resolver defined for path: ${filename}`);
			});

		this.$parser = options.engine?.parser ?? Parser;
		this.$compiler = options.engine?.compiler ?? Compiler;

		// Collect plugins to load
		const pluginsToLoad: Array<{ p: KirePlugin<any>; o?: any }> = [];

		// Register default directives
		if (
			typeof options.directives === "undefined" ||
			options.directives === true
		) {
			pluginsToLoad.push({ p: KireDirectives });
		}

		// User provided plugins
		if (options.plugins) {
			for (const p of options.plugins) {
				if (Array.isArray(p)) {
					pluginsToLoad.push({ p: p[0], o: p[1] });
				} else {
					pluginsToLoad.push({ p });
				}
			}
		}

		pluginsToLoad.sort((a, b) => (a.p.sort ?? 100) - (b.p.sort ?? 100));

		for (const item of pluginsToLoad) {
			this.plugin(item.p, item.o);
		}
	}

	public plugin<KirePlugged extends KirePlugin<any>>(
		plugin: KirePlugged,
		opts?: KirePlugged["options"],
	) {
		if (typeof plugin === "function") {
			(plugin as any)(this, opts);
		} else if (plugin.load) {
			plugin.load(this, opts);
		}
		return this;
	}

	public pkgSchema(
		name: string,
		repository?: string | { type: string; url: string },
		version?: string,
	): KireSchematic {
		const globals: Record<string, any> = {};
		this.$globals.forEach((value, key) => {
			globals[key] = value;
		});

		return {
			package: name,
			repository,
			version,
			directives: Array.from(this.$directives.values()),
			elements: Array.from(this.$elements.values()),
			globals: globals,
		};
	}

	public element(
		nameOrDef: string | RegExp | ElementDefinition,
		handler?: KireElementHandler,
		options?: KireElementOptions,
	) {
		if (
			typeof nameOrDef === "object" &&
			"onCall" in nameOrDef &&
			!("source" in nameOrDef)
		) {
			this.$elements.add(nameOrDef as ElementDefinition);
		} else {
			if (!handler) throw new Error("Handler is required for legacy element()")
			this.$elements.add({
				name: nameOrDef as string | RegExp,
				void: options?.void ?? false, // Default to false if not provided
				onCall: handler,
			});
		}
		return this;
	}

	public directive(def: DirectiveDefinition) {
		this.$directives.set(def.name, def);
		if (def.parents) {
			for (const parent of def.parents) {
				this.directive(parent);
			}
		}
		return this;
	}

	public getDirective(name: string) {
		return this.$directives.get(name);
	}

	public $ctx(key: string, value: any) {
		this.$globals.set(key, value);
		return this;
	}

	public parse(template: string) {
		const parser = new this.$parser(template, this);
		return parser.parse();
	}

	public async compile(template: string): Promise<string> {
		const parser = new this.$parser(template, this);
		const nodes = parser.parse();
		const compiler = new this.$compiler(this);
		return compiler.compile(nodes);
	}

	public async compileFn(content: string): Promise<Function> {
		const code = await this.compile(content);
		//console.log(code)
		try {
			const AsyncFunction = Object.getPrototypeOf(async () => { }).constructor;

			const mainFn = new AsyncFunction("$ctx", code);
			(mainFn as any)._code = code;

			// Return the separated functions
			return mainFn;
		} catch (e) {
			console.error("Error creating function from code:", code);
			throw e;
		}
	}

	public async render(
		template: string,
		locals: Record<string, any> = {},
	): Promise<string> {
		const fn = await this.compileFn(template);
		return this.run(fn, locals);
	}

	public async view(
		path: string,
		locals: Record<string, any> = {},
	): Promise<string> {
		const resolvedPath = resolvePath(path, this.root, this.alias, this.extension);
		let compiled: Function | undefined;

		if (this.production && this.$files.has(resolvedPath)) {
			compiled = this.$files.get(resolvedPath) as any;
		} else {
			try {
				const content = await this.$resolver(resolvedPath);
				compiled = await this.compileFn(content);
				if (this.production) {
					this.$files.set(resolvedPath, compiled as any);
				}
			} catch (e) {
				throw e;
			}
		}

		if (!compiled) throw new Error(`Could not load view: ${path}`);
		return this.run(compiled, locals);
	}

	public resolvePath(
		filepath: string,
		currentFile?: string,
	): string {
		return resolvePath(filepath, this.root, this.alias, this.extension, currentFile);
	}

	public async run(mainFn: Function, locals: Record<string, any>, children = false) {
		const rctx: any = {};
		for (const [k, v] of this.$globals) {
			rctx[k] = v;
		}
		Object.assign(rctx, locals);

		if (this.$expose_locals) {
			rctx[this.$var_locals] = locals;
		}

		rctx['~res'] = "";
		rctx['~$pre'] = [];
		rctx['~$pos'] = [];

		rctx.res = function (this: any, str: any) {
			rctx['~res'] += str;
		};

		rctx.$res = () => rctx['~res'];

		rctx.$resolve = (path: string) => {
			return this.resolvePath(path);
		};

		rctx.$merge = async (func: Function) => {
			const parentRes = rctx['~res'];
			rctx['~res'] = "";
			await func(rctx);
			rctx['~res'] = parentRes + rctx['~res'];
		};

		// Execute onInit for all directives
		if (this.$directives.size > 0) {
			for (const directive of this.$directives.values()) {
				if (directive.onInit) {
					await directive.onInit(rctx);
				}
			}
		}

		let finalCtx: any;
		try {
			//console.log(mainFn.toString())
			finalCtx = await mainFn(rctx);
		} catch (e: any) {
			if ((mainFn as any)._code) {
				e.kireGeneratedCode = (mainFn as any)._code;
			}
			throw e;
		}
		finalCtx.$typed = (key:string) => finalCtx[key];

		// Execute ~$pre functions collected during execution
		if (finalCtx['~$pre'] && finalCtx['~$pre'].length > 0) {
			for (const preFn of finalCtx['~$pre']) {
				await preFn(finalCtx);
			}
		}

		let resultHtml = finalCtx['~res'];

		// Execute ~$pos functions (deferred logic)
		if (finalCtx['~$pos'] && finalCtx['~$pos'].length > 0) {
			for (const posFn of finalCtx['~$pos']) {
				await posFn(finalCtx);
			}
			resultHtml = finalCtx['~res'];
		}

		if (!children && this.$elements.size > 0) {
			for (const def of this.$elements) {
				const tagName =
					def.name instanceof RegExp ? def.name.source : def.name;

				const isVoid =
					def.void ||
					(typeof def.name === "string" &&
						/^(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)$/i.test(
							def.name,
						));

				const regex = isVoid
					? new RegExp(`<(${tagName})([^>]*)>`, "gi")
					: new RegExp(
						`<(${tagName})([^>]*)>([\\s\\S]*?)<\\/\\1>`,
						"gi",
					);

				const matches = [];
				let match:RegExpExecArray | null;
				while ((match = regex.exec(resultHtml)) !== null) {
					matches.push({
						full: match[0],
						tagName: match[1],
						attrs: match[2],
						inner: isVoid ? "" : match[3],
						index: match.index,
					});
				}

				for (const m of matches) {
					if (!resultHtml.includes(m.full)) {
						continue;
					}

					const attributes: Record<string, string> = {};
					const attrRegex = /([a-zA-Z0-9_-]+)(?:="([^"]*)")?/g;
					let attrMatch:RegExpExecArray | null;
					while ((attrMatch = attrRegex.exec(m.attrs!)) !== null) {
						attributes[attrMatch[1]!] = attrMatch[2] ?? "";
					}

					const elCtx: any = Object.create(finalCtx);
					elCtx.content = resultHtml;
					elCtx.element = {
						tagName: m.tagName,
						attributes,
						inner: m.inner,
						outer: m.full,
					};
					elCtx.update = (newContent: string) => {
						resultHtml = newContent;
						elCtx.content = newContent;
					};
					elCtx.replace = (replacement: string) => {
						resultHtml = resultHtml.replace(m.full, replacement);
						elCtx.content = resultHtml;
					};
					elCtx.replaceElement = (replacement: string) => {
						resultHtml = resultHtml.replace(m.full, replacement);
						elCtx.content = resultHtml;
					};
					elCtx.replaceContent = (replacement: string) => {
						if (!isVoid) {
							const newOuter = m.full.replace(m.inner!, replacement);
							resultHtml = resultHtml.replace(m.full, newOuter);
							elCtx.content = resultHtml;
						}
					};

					await def.onCall(elCtx);

					if (elCtx.content !== resultHtml) {
						resultHtml = elCtx.content;
					}
				}
			}
		}

		return resultHtml;
	}
}

// --- From: core/src/index.ts ---
export * from "./compiler";
export * from "./kire";
export * from "./parser";
export * from "./types";


// --- From: core/src/directives/import.ts ---
import type { Kire } from "../kire";

export default (kire: Kire) => {
	kire.directive({
		name: "include",
		params: ["path:string", "locals:object"],
		children: false,
		type: "html",
		description:
			"Includes and renders a template from a given path, optionally passing local variables.",
		example: `@include('partials/card')`,
		onCall(compiler) {
			const pathExpr = compiler.param("path");
			const localsExpr = compiler.param("locals") || "{}";

			compiler.raw(`await $ctx.$merge(async ($ctx) => {
    const html = await $ctx.$require(${JSON.stringify(pathExpr)}, ${localsExpr});
    if (html !== null) {
        $ctx.res(html);
    }
});`);
		},
	});
};

// --- From: core/src/directives/natives.ts ---
import type { Kire } from "../kire";

export default (kire: Kire) => {
	kire.directive({
		name: "if",
		params: ["cond:string"],
		children: true,
		type: "js",
		description:
			"Conditionally renders a block of content if the expression is true.",
		example: `@if(user.isLoggedIn)\n  Welcome, {{ user.name }}!\n@end`,
		parents: [
			{
				name: "elseif",
				params: ["cond:string"],
				children: true,
				type: "js",
				description:
					"Renders a block of content if the preceding @if/@elseif is false and the current expression is true.",
				example: `@elseif(user.isAdmin)\n  Admin access granted.\n@end`,
				async onCall(compiler) {
					compiler.raw(`} else if (${compiler.param("cond")}) {`);
					if (compiler.children) await compiler.set(compiler.children);
				},
			},
			{
				name: "elif", // alias for elseif
				params: ["cond:string"],
				children: true,
				type: "js",
				description: "Alias for @elseif.",
				example: `@elif(user.isAdmin)\n  Admin access granted.\n@end`,
				async onCall(compiler) {
					compiler.raw(`} else if (${compiler.param("cond")}) {`);
					if (compiler.children) await compiler.set(compiler.children);
				},
			},
			{
				name: "else",
				children: true,
				type: "js",
				description:
					"Renders a block of content if the preceding @if/@elseif expressions are all false.",
				example: `@else\n  Please log in.\n@end`,
				async onCall(compiler) {
					compiler.raw(`} else {`);
					if (compiler.children) await compiler.set(compiler.children);
				},
			},
		],
		async onCall(compiler) {
			compiler.raw(`if (${compiler.param("cond")}) {`);
			if (compiler.children) await compiler.set(compiler.children);
			if (compiler.parents) await compiler.set(compiler.parents);
			compiler.raw("}");
		},
	});

	kire.directive({
		name: "for",
		params: ["expr:string"],
		children: true,
		type: "js",
		description:
			"Iterates over an array or object, similar to a JavaScript for...of loop.",
		example: `@for(user of users)\n  <p>{{ user.name }}</p>\n@end`,
		async onCall(compiler) {
			const expr = compiler.param("expr");
			if (expr.includes(" in ")) {
				const [lhs, rhs] = expr.split(" in ");
				compiler.raw(`for (const ${lhs.trim()} in ${rhs.trim()}) {`);
			} else if (expr.includes(" of ")) {
				const [lhs, rhs] = expr.split(" of ");
				compiler.raw(`for (const ${lhs.trim()} of ${rhs.trim()}) {`);
			} else {
				compiler.raw(`for (${expr}) {`);
			}

			if (compiler.children) await compiler.set(compiler.children);
			compiler.raw(`}`);
		},
	});

	kire.directive({
		name: "const",
		params: ["expr:string"],
		type: "js",
		description:
			"Declares a block-scoped constant, similar to JavaScript `const`.",
		example: `@const(myVar = 'hello world')`,
		onCall(compiler) {
			compiler.raw(`const ${compiler.param("expr")};`);
		},
	});

	kire.directive({
		name: "let",
		params: ["expr:string"],
		type: "js",
		description:
			"Declares a block-scoped local variable, similar to JavaScript `let`.",
		example: `@let(counter = 0)`,
		onCall(compiler) {
			compiler.raw(`let ${compiler.param("expr")};`);
		},
	});

	kire.directive({
		name: "code",
		children: true,
		type: "js",
		description: "Executes a block of raw JavaScript code on the server.",
		example: `@code\n  console.log('This runs during template compilation.');\n@end`,
		onCall(compiler) {
			if (compiler.children) {
				let code = "";
				for (const child of compiler.children) {
					if (child.type === "text" && child.content) {
						code += child.content;
					}
				}
				if (code) {
					compiler.raw(code);
				}
			}
		},
	});

	// Register case and default globally/independently so they are not treated as chained parents of switch
	kire.directive({
		name: "case",
		params: ["val:string"],
		children: true,
		type: "js",
		description: "A case clause for a @switch statement.",
		example: `@case('A')\n  <p>Value is A</p>\n@end`,
		async onCall(c) {
			c.raw(`case ${JSON.stringify(c.param("val"))}: {`);
			if (c.children) await c.set(c.children);
			c.raw(`break; }`);
		},
	});

	kire.directive({
		name: "default",
		children: true,
		type: "js",
		description: "The default clause for a @switch statement.",
		example: `@default\n  <p>Value is something else</p>\n@end`,
		async onCall(c) {
			c.raw(`default: {`);
			if (c.children) await c.set(c.children);
			c.raw(`}`);
		},
	});

	kire.directive({
		name: "switch",
		params: ["expr:string"],
		children: true,
		type: "js",
		description:
			"Provides a control flow statement similar to a JavaScript switch block.",
		example: `@switch(value)\n  @case(1) ... @end\n  @default ... @end\n@end`,
		async onCall(compiler) {
			compiler.raw(`switch (${compiler.param("expr")}) {`);
			if (compiler.children) {
				// Filter only case/default nodes to avoid invalid JS (text nodes in switch block)
				const cases = compiler.children.filter(n => n.name === 'case' || n.name === 'default');
				await compiler.set(cases);
			}
			compiler.raw(`}`);
		},
	});
};


// --- From: core/src/directives/component.ts ---
import type { Kire } from "../kire";

export default (kire: Kire) => {
	// @component('path', {vars}) ... @end
	// Uses slots.

	kire.directive({
		name: "slot",
		params: ["name:string"],
		children: true,
		type: "html",
		description: "Defines a named content slot within a component.",
		example: `@slot('header')\n  <h1>This is the header</h1>\n@end`,
		onCall(compiler) {
			const name = compiler.param("name");
			compiler.raw(`await $ctx.$merge(async ($ctx) => {`);
			if (compiler.children) compiler.set(compiler.children);
			compiler.raw(`  $slots[${JSON.stringify(name)}] = $ctx['~res'];`);
			compiler.raw(`  $ctx['~res'] = '';`);
			compiler.raw(`});`);
		},
	});

	kire.directive({
		name: "component",
		params: ["path:string", "variables:object"],
		children: true,
		type: "html",
		description:
			"Loads a template as a reusable component, allowing content to be passed into named slots.",
		example: `@component('card', { title: 'My Card' })\n  @slot('header')\n    <h1>Card Header</h1>\n  @end\n  <p>Default content.</p>\n@end`,
		async onCall(compiler) {
			const pathExpr = compiler.param("path");
			const varsExpr = compiler.param("variables") || "{}";

			compiler.raw(`await (async () => {`);
			compiler.raw(`  const $slots = {};`);

			// Run children to populate slots
			compiler.raw(`  await $ctx.$merge(async ($ctx) => {`);
			compiler.raw(`    $ctx.slots = $slots;`); // Still expose slots to children if they need it
			
			if (compiler.children) await compiler.set(compiler.children);

			compiler.raw(`    if (!$slots.default) $slots.default = $ctx['~res'];`);
			compiler.raw(`    $ctx['~res'] = '';`); // Clear default content from parent stream
			compiler.raw(`  });`);

			// Now load the component template and render it
			compiler.raw(`  const path = ${JSON.stringify(pathExpr)};`);
			compiler.raw(`  const componentLocals = ${varsExpr};`);
			
			compiler.raw(`  const finalLocals = { ...componentLocals };`);
			compiler.raw(`  if (typeof finalLocals === 'object' && finalLocals !== null) finalLocals.slots = $slots;`); // Add slots to locals

			compiler.raw(`  const html = await $ctx.$require(path, finalLocals);`);
			compiler.raw(`  if (html !== null) {`);
			compiler.raw(`    $ctx.res(html);`);
			compiler.raw(`  }`);

			compiler.raw(`})();`);
		},
	});
};

// --- From: core/src/directives/layout.ts ---
import type { Kire } from "../kire";

export default (kire: Kire) => {
	kire.directive({
		name: "define",
		params: ["name:string"],
		children: true,
		type: "html",
		description: "Defines a named, reusable section of content.",
		example: `@define('header')\n  <h1>My Website</h1>\n@end`,
		async onCall(ctx) {
			const name = ctx.param("name");

			if (ctx.children) {
				ctx.raw(`await $ctx.$merge(async ($ctx) => {`);
				await ctx.set(ctx.children);
				ctx.raw(`  $ctx['~defines'][${JSON.stringify(name)}] = $ctx['~res'];`);
				ctx.raw(`  $ctx['~res'] = '';`);
				ctx.raw(`});`);
			}
		},
	});

	kire.element('kire:defined', (ctx) => {
		const defines = ctx.$typed<Record<string, string>>('~defines');
		const id = ctx.element.attributes.id!;
		if (defines[id] !== undefined) {
			ctx.replaceElement(defines[id]);
		}
	})

	kire.directive({
		name: "defined",
		params: ["name:string"],
		children: "auto",
		type: "html",
		description: "Renders defined content or fallback.",
		example: `@defined('header')\n  Conteúdo não encontrado\n@end`,
		onInit(ctx) {
			ctx["~defines"] = ctx["~defines"] || {};
		},
		async onCall(ctx) {
			const name = ctx.param("name");

			if (ctx.children?.length) {
				ctx.res(`<kire:defined id=${JSON.stringify(name)}>`);
				await ctx.set(ctx.children);
				ctx.res(`</kire:defined>`);
			} else {
				ctx.res(`<kire:defined id=${JSON.stringify(name)}></kire:defined>`);
			}
		},
	});

	kire.directive({
		name: "stack",
		params: ["name:string"],
		type: "html",
		description:
			"Creates a placeholder where content pushed to a named stack will be rendered.",
		example: `<html>\n<head>\n  @stack('scripts')\n</head>\n</html>`,
		children: false,
		onCall(compiler) {
			const name = compiler.param("name");
			compiler.raw(
				`$ctx.res("<!-- KIRE:stack(" + ${JSON.stringify(name)} + ") -->");`
			);
		},
		onInit(ctx) {
			ctx['~stacks'] = ctx['~stacks'] || {};
			
			ctx['~$pos'].push(async (c: any) => {
				const ctx = c as any;
				if (ctx['~stacks']) {
					for (const key in ctx['~stacks']) {
						const placeholder = "<!-- KIRE:stack(" + key + ") -->";
						if (ctx['~res'].includes(placeholder)) {
							const content = ctx['~stacks'][key].join('\n');
							ctx['~res'] = ctx['~res'].split(placeholder).join(content);
						}
					}
					ctx['~res'] = ctx['~res'].replace(/<!-- KIRE:stack\(.*?\) -->/g, '');
				}
			});
		}
	});

	kire.directive({
		name: "push",
		params: ["name:string"],
		children: true,
		type: "html",
		description: "Pushes a block of content onto a named stack.",
		example: `@push('scripts')\n  <script src="app.js"></script>\n@end`,
		async onCall(compiler) {
			const name = compiler.param("name");
			compiler.raw(`if(!$ctx['~stacks']) $ctx['~stacks'] = {};`);
			compiler.raw(
				`if (!$ctx['~stacks'][${JSON.stringify(name)}]) $ctx['~stacks'][${JSON.stringify(name)}] = [];`
			);
			compiler.raw(
				`await $ctx.$merge(async ($ctx) => {`
			);

			if (compiler.children) await compiler.set(compiler.children);

			compiler.raw(`  $ctx['~stacks'][${JSON.stringify(name)}].push($ctx['~res']);`);
			compiler.raw(`  $ctx['~res'] = '';`);
			compiler.raw(`});`);
		},
	});
};

// --- From: core/src/directives/index.ts ---
import type { KirePlugin } from "../types";
import { md5 } from "../utils/md5";
import { resolvePath } from "../utils/resolve";
import componentDirectives from "./component";
import importDirectives from "./import";
import defineDirectives from "./layout";
import nativeDirectives from "./natives";

export const KireDirectives: KirePlugin = {
	name: "@kirejs/core",
	sort: 100,
	options: {},
	load(kire) {
		// Register internal helpers
		// add md5 function
		kire.$ctx("$md5", md5);
		kire.$ctx("$escape", escapeHtml);
		kire.$ctx(
			"$require",
			async (path: string, locals: Record<string, any> = {}) => {
				// Use absolute path for caching key to avoid conflicts
				const resolvedPath = resolvePath(
					path,
					kire.root,
					kire.alias,
					kire.extension,
				);

				const cached = kire.cached("@kirejs/core");
				const isProd = kire.production;
				const cachedHash = cached.get(`md5:${resolvedPath}`);
				let compiledFn: Function | undefined = cached.get(`js:${resolvedPath}`);
				let content = "";

				if (!cachedHash || !compiledFn || !isProd) {
					try {
						content = await kire.$resolver(resolvedPath);
					} catch (e: any) {
						if (!e.message.includes("No resolver")) {
							console.warn(`Failed to resolve path: ${resolvedPath}`, e);
						}
						return null; // Retorna null se não encontrar, para a diretiva lidar
					}

					if (!content) {
						return null;
					}

					const newHash = md5(content);

					if (cachedHash === newHash && compiledFn) {
						// Optimization: Content hasn't changed, reuse cached function
					} else {
						compiledFn = await kire.compileFn(content);
						cached.set(`md5:${resolvedPath}`, newHash);
						cached.set(`js:${resolvedPath}`, compiledFn); // Cache a função compilada
					}
				}

				if (!compiledFn) return null; // Retorna null se a função não foi compilada/cacheada

				// Executa a função compilada com os locals e retorna o HTML
				// We need to cast kire to any or make run public to access it from here since it was private
				return (kire as any).run(compiledFn, locals);
			}
		);

		defineDirectives(kire);
		nativeDirectives(kire);
		importDirectives(kire);
		componentDirectives(kire);
	},
};

function escapeHtml(unsafe: any): string {
	if (unsafe === null || unsafe === undefined) return "";
	return String(unsafe)
		.replace(/&/g, "&amp;")
		.replace(/</g, "&lt;")
		.replace(/>/g, "&gt;")
		.replace(/"/g, "&quot;")
		.replace(/'/g, "&#039;");
}

// --- From: core/src/utils/resolve.ts ---
import { join } from "./path";

export function resolvePath(
	filepath: string,
	root: string,
	alias: Record<string, string>,
	extension?: string,
	currentFile?: string,
): string {
	if (!filepath) return filepath;

	if (filepath.startsWith("http://") || filepath.startsWith("https://")) {
		return filepath;
	}

	let resolved = filepath.replace(/\\/g, "/").replace(/(?<!:)\/+/g, "/");
	const normalizedRoot = root.replace(/\\/g, "/").replace(/\/\/$/, "");

	const isWindowsAbsolute = /^[a-zA-Z]:\/$/.test(resolved);

	const aliases = Object.entries(alias);
	aliases.sort((a, b) => b[0].length - a[0].length);

	let matchedAlias = false;
	for (const [aliasKey, replacement] of aliases) {
		const escapedAlias = aliasKey.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
		if (new RegExp(`^${escapedAlias}`).test(filepath)) {
			resolved = join(replacement, filepath.slice(aliasKey.length));
			matchedAlias = true;
			break;
		}
	}

	if (matchedAlias) {
		// handled
	} else {
		const isResolvedAbsolute = /^(?:\/|[a-zA-Z]:\/)/.test(resolved);
		if (!isResolvedAbsolute && !isWindowsAbsolute) {
			const base = currentFile
				? currentFile.replace(/\\/g, "/").replace(/\/[^/]*$/, "")
				: normalizedRoot;
			resolved = join(base, resolved);
		}
	}

	if (
		extension &&
		!/\.[^/.]+$/.test(resolved) &&
		!(resolved.startsWith("http://") || resolved.startsWith("https://"))
	) {
		const ext = extension.charAt(0) === "." ? extension : `.${extension}`;
		resolved += ext;
	}

	return resolved.replace(/\/+/g, "/");
}


// --- From: core/src/utils/path.ts ---
/**
 * Joins path segments and normalizes the resulting path
 */
export function join(...segments: string[]): string {
	if (!segments.length) return ".";

	const windowsAbsoluteRegex = /^[a-zA-Z]:[\\/]/;
	const isWindowsAbsolute = segments.some((s) => windowsAbsoluteRegex.test(s));
	const driveLetter = isWindowsAbsolute
		? segments
				.find((s) => windowsAbsoluteRegex.test(s))
				?.charAt(0)
				.toUpperCase()
		: null;

	// Normalize all segments at once
	const normalized = segments
		.join("/")
		.replace(/\\/g, "/")
		.replace(/\/+/g, "/");
	const isAbsolute = /^(?:\/|[a-zA-Z]:\/)/.test(normalized);

	const parts = normalized.split("/");
	const result: string[] = [];
	let i = 0;

	while (i < parts.length) {
		const part = parts[i++];
		if (!part || part === ".") continue;

		if (part === "..") {
			if (result.length && result[result.length - 1] !== "..") {
				result.pop();
			} else {
				result.push(part);
			}
		} else {
			result.push(part);
		}
	}

	let path = result.join("/");

	if (isWindowsAbsolute && driveLetter) {
		path = path.replace(/^[a-zA-Z]:/, "").replace(/^\//, "");
		path = `${driveLetter}:\\${path.replace(/\//g, "\\")}`.replace(
			/\\+/g,
			"\\",
		);
		return path || ".";
	}

	return isAbsolute ? `/${path.replace(/^\//, "")}` : path || ".";
}


// --- From: core/src/utils/md5.ts ---

export function md5(string: string): string {
	function rotateLeft(lValue: number, iShiftBits: number): number {
		return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
	}

	function addUnsigned(lX: number, lY: number): number {
		const lX8 = lX & 0x80000000;
		const lY8 = lY & 0x80000000;
		const lX4 = lX & 0x40000000;
		const lY4 = lY & 0x40000000;
		const lResult = (lX & 0x3fffffff) + (lY & 0x3fffffff);
		if (lX4 & lY4) {
			return lResult ^ 0x80000000 ^ lX8 ^ lY8;
		}
		if (lX4 | lY4) {
			if (lResult & 0x40000000) {
				return lResult ^ 0xc0000000 ^ lX8 ^ lY8;
			} else {
				return lResult ^ 0x40000000 ^ lX8 ^ lY8;
			}
		} else {
			return lResult ^ lX8 ^ lY8;
		}
	}

	function F(x: number, y: number, z: number): number {
		return (x & y) | (~x & z);
	}
	function G(x: number, y: number, z: number): number {
		return (x & z) | (y & ~z);
	}
	function H(x: number, y: number, z: number): number {
		return x ^ y ^ z;
	}
	function I(x: number, y: number, z: number): number {
		return y ^ (x | ~z);
	}

	function FF(
		a: number,
		b: number,
		c: number,
		d: number,
		x: number,
		s: number,
		ac: number,
	): number {
		a = addUnsigned(a, addUnsigned(addUnsigned(F(b, c, d), x), ac));
		return addUnsigned(rotateLeft(a, s), b);
	}

	function GG(
		a: number,
		b: number,
		c: number,
		d: number,
		x: number,
		s: number,
		ac: number,
	): number {
		a = addUnsigned(a, addUnsigned(addUnsigned(G(b, c, d), x), ac));
		return addUnsigned(rotateLeft(a, s), b);
	}

	function HH(
		a: number,
		b: number,
		c: number,
		d: number,
		x: number,
		s: number,
		ac: number,
	): number {
		a = addUnsigned(a, addUnsigned(addUnsigned(H(b, c, d), x), ac));
		return addUnsigned(rotateLeft(a, s), b);
	}

	function II(
		a: number,
		b: number,
		c: number,
		d: number,
		x: number,
		s: number,
		ac: number,
	): number {
		a = addUnsigned(a, addUnsigned(addUnsigned(I(b, c, d), x), ac));
		return addUnsigned(rotateLeft(a, s), b);
	}

	function convertToWordArray(string: string): number[] {
		let lWordCount:number;
		const lMessageLength = string.length;
		const lNumberOfWords_temp1 = lMessageLength + 8;
		const lNumberOfWords_temp2 =
			(lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
		const lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
		const lWordArray = Array(lNumberOfWords - 1);
		let lBytePosition = 0;
		let lByteCount = 0;
		while (lByteCount < lMessageLength) {
			lWordCount = (lByteCount - (lByteCount % 4)) / 4;
			lBytePosition = (lByteCount % 4) * 8;
			lWordArray[lWordCount] =
				(lWordArray[lWordCount] || 0) |
				(string.charCodeAt(lByteCount) << lBytePosition);
			lByteCount++;
		}
		lWordCount = (lByteCount - (lByteCount % 4)) / 4;
		lBytePosition = (lByteCount % 4) * 8;
		lWordArray[lWordCount] = (lWordArray[lWordCount] || 0) | (0x80 << lBytePosition);
		lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
		lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
		
		// Ensure no undefined holes
		for(let i=0; i<lWordArray.length; i++) {
			if(lWordArray[i] === undefined) lWordArray[i] = 0;
		}
		return lWordArray;
	}

	function wordToHex(lValue: number): string {
		let WordToHexValue = "";
		let WordToHexValue_temp = "";
		for (let lCount = 0; lCount <= 3; lCount++) {
			const lByte = (lValue >>> (lCount * 8)) & 255;
			WordToHexValue_temp = `0${lByte.toString(16)}`;
			WordToHexValue =
				WordToHexValue +
				WordToHexValue_temp.substr(WordToHexValue_temp.length - 2, 2);
		}
		return WordToHexValue;
	}

	let x: number[] = [];
	let k: number = 0, 
		AA: number = 0, 
		BB: number = 0, 
		CC: number = 0, 
		DD: number = 0, 
		a: number = 0, 
		b: number = 0, 
		c: number = 0, 
		d: number = 0;
	const S11 = 7,
		S12 = 12,
		S13 = 17,
		S14 = 22;
	const S21 = 5,
		S22 = 9,
		S23 = 14,
		S24 = 20;
	const S31 = 4,
		S32 = 11,
		S33 = 16,
		S34 = 23;
	const S41 = 6,
		S42 = 10,
		S43 = 15,
		S44 = 21;

	x = convertToWordArray(string);
	a = 0x67452301;
	b = 0xefcdab89;
	c = 0x98badcfe;
	d = 0x10325476;

	for (k = 0; k < x.length; k += 16) {
		AA = a;
		BB = b;
		CC = c;
		DD = d;
		a = FF(a, b, c, d, x[k + 0] || 0, S11, 0xd76aa478);
		d = FF(d, a, b, c, x[k + 1] || 0, S12, 0xe8c7b756);
		c = FF(c, d, a, b, x[k + 2] || 0, S13, 0x242070db);
		b = FF(b, c, d, a, x[k + 3] || 0, S14, 0xc1bdceee);
		a = FF(a, b, c, d, x[k + 4] || 0, S11, 0xf57c0faf);
		d = FF(d, a, b, c, x[k + 5] || 0, S12, 0x4787c62a);
		c = FF(c, d, a, b, x[k + 6] || 0, S13, 0xa8304613);
		b = FF(b, c, d, a, x[k + 7] || 0, S14, 0xfd469501);
		a = FF(a, b, c, d, x[k + 8] || 0, S11, 0x698098d8);
		d = FF(d, a, b, c, x[k + 9] || 0, S12, 0x8b44f7af);
		c = FF(c, d, a, b, x[k + 10] || 0, S13, 0xffff5bb1);
		b = FF(b, c, d, a, x[k + 11] || 0, S14, 0x895cd7be);
		a = FF(a, b, c, d, x[k + 12] || 0, S11, 0x6b901122);
		d = FF(d, a, b, c, x[k + 13] || 0, S12, 0xfd987193);
		c = FF(c, d, a, b, x[k + 14] || 0, S13, 0xa679438e);
		b = FF(b, c, d, a, x[k + 15] || 0, S14, 0x49b40821);
		a = GG(a, b, c, d, x[k + 1] || 0, S21, 0xf61e2562);
		d = GG(d, a, b, c, x[k + 6] || 0, S22, 0xc040b340);
		c = GG(c, d, a, b, x[k + 11] || 0, S23, 0x265e5a51);
		b = GG(b, c, d, a, x[k + 0] || 0, S24, 0xe9b6c7aa);
		a = GG(a, b, c, d, x[k + 5] || 0, S21, 0xd62f105d);
		d = GG(d, a, b, c, x[k + 10] || 0, S22, 0x02441453);
		c = GG(c, d, a, b, x[k + 15] || 0, S23, 0xd8a1e681);
		b = GG(b, c, d, a, x[k + 4] || 0, S24, 0xe7d3fbc8);
		a = GG(a, b, c, d, x[k + 9] || 0, S21, 0x21e1cde6);
		d = GG(d, a, b, c, x[k + 14] || 0, S22, 0xc33707d6);
		c = GG(c, d, a, b, x[k + 3] || 0, S23, 0xf4d50d87);
		b = GG(b, c, d, a, x[k + 8] || 0, S24, 0x455a14ed);
		a = GG(a, b, c, d, x[k + 13] || 0, S21, 0xa9e3e905);
		d = GG(d, a, b, c, x[k + 2] || 0, S22, 0xfcefa3f8);
		c = GG(c, d, a, b, x[k + 7] || 0, S23, 0x676f02d9);
		b = GG(b, c, d, a, x[k + 12] || 0, S24, 0x8d2a4c8a);
		a = HH(a, b, c, d, x[k + 5] || 0, S31, 0xfffa3942);
		d = HH(d, a, b, c, x[k + 8] || 0, S32, 0x8771f681);
		c = HH(c, d, a, b, x[k + 11] || 0, S33, 0x6d9d6122);
		b = HH(b, c, d, a, x[k + 14] || 0, S34, 0xfde5380c);
		a = HH(a, b, c, d, x[k + 1] || 0, S31, 0xa4beea44);
		d = HH(d, a, b, c, x[k + 4] || 0, S32, 0x4bdecfa9);
		c = HH(c, d, a, b, x[k + 7] || 0, S33, 0xf6bb4b60);
		b = HH(b, c, d, a, x[k + 10] || 0, S34, 0xbebfbc70);
		a = HH(a, b, c, d, x[k + 13] || 0, S31, 0x289b7ec6);
		d = HH(d, a, b, c, x[k + 0] || 0, S32, 0xeaa127fa);
		c = HH(c, d, a, b, x[k + 3] || 0, S33, 0xd4ef3085);
		b = HH(b, c, d, a, x[k + 6] || 0, S34, 0x04881d05);
		a = HH(a, b, c, d, x[k + 9] || 0, S31, 0xd9d4d039);
		d = HH(d, a, b, c, x[k + 12] || 0, S32, 0xe6db99e5);
		c = HH(c, d, a, b, x[k + 15] || 0, S33, 0x1fa27cf8);
		b = HH(b, c, d, a, x[k + 2] || 0, S34, 0xc4ac5665);
		a = II(a, b, c, d, x[k + 0] || 0, S41, 0xf4292244);
		d = II(d, a, b, c, x[k + 7] || 0, S42, 0x432aff97);
		c = II(c, d, a, b, x[k + 14] || 0, S43, 0xab9423a7);
		b = II(b, c, d, a, x[k + 5] || 0, S44, 0xfc93a039);
		a = II(a, b, c, d, x[k + 12] || 0, S41, 0x655b59c3);
		d = II(d, a, b, c, x[k + 3] || 0, S42, 0x8f0ccc92);
		c = II(c, d, a, b, x[k + 10] || 0, S43, 0xffeff47d);
		b = II(b, c, d, a, x[k + 1] || 0, S44, 0x85845dd1);
		a = II(a, b, c, d, x[k + 8] || 0, S41, 0x6fa87e4f);
		d = II(d, a, b, c, x[k + 15] || 0, S42, 0xfe2ce6e0);
		c = II(c, d, a, b, x[k + 6] || 0, S43, 0xa3014314);
		b = II(b, c, d, a, x[k + 13] || 0, S44, 0x4e0811a1);
		a = II(a, b, c, d, x[k + 4] || 0, S41, 0xf7537e82);
		d = II(d, a, b, c, x[k + 11] || 0, S42, 0xbd3af235);
		c = II(c, d, a, b, x[k + 2] || 0, S43, 0x2ad7d2bb);
		b = II(b, c, d, a, x[k + 9] || 0, S44, 0xeb86d391);
		a = addUnsigned(a, AA);
		b = addUnsigned(b, BB);
		c = addUnsigned(c, CC);
		d = addUnsigned(d, DD);
	}
	const temp = wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d);
	return temp.toLowerCase();
}


