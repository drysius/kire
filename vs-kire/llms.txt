// Combined source for vs-kire

// --- From: vs-kire/src/store.ts ---
import { createStore } from 'zustand/vanilla';

export interface DirectiveDefinition {
	name: string;
	params?: string[];
	children?: boolean | "auto";
	type?: "css" | "js" | "html";
	description?: string;
	example?: string;
    parents?: DirectiveDefinition[];
}

export interface ElementDefinition {
	name: string;
	description?: string;
	example?: string;
	void?: boolean;
}

export interface KireState {
	directives: Map<string, DirectiveDefinition>;
	elements: Map<string, ElementDefinition>;
    // Helpers to quickly find parent directives for sub-directives
    parentDirectives: Map<string, string[]>; // subDirective -> [parentName1, parentName2]
	addDirectives: (directives: DirectiveDefinition[]) => void;
	addElements: (elements: ElementDefinition[]) => void;
    clear: () => void;
}

export const kireStore = createStore<KireState>((set) => ({
	directives: new Map(),
	elements: new Map(),
    parentDirectives: new Map(),
	addDirectives: (directives) =>
		set((state) => {
			const newMap = new Map(state.directives);
            const newParents = new Map(state.parentDirectives);

			directives.forEach((d) => {
                newMap.set(d.name, d);
                // Handle nested parents/sub-directives
                if (d.parents) {
                    d.parents.forEach(p => {
                        // p is a sub-directive definition (like elseif)
                        // It might not have a full definition in the top-level list, or it might.
                        // Usually sub-directives are defined inline in the schema under 'parents'.
                        // We should probably index them too if we want to hover over @elseif
                        newMap.set(p.name, p);
                        
                        const parents = newParents.get(p.name) || [];
                        if (!parents.includes(d.name)) {
                            parents.push(d.name);
                        }
                        newParents.set(p.name, parents);
                    });
                }
            });
			return { directives: newMap, parentDirectives: newParents };
		}),
	addElements: (elements) =>
		set((state) => {
			const newMap = new Map(state.elements);
			// biome-ignore lint/suspicious/useIterableCallbackReturn: ignore
			elements.forEach((e) => newMap.set(e.name, e));
			return { elements: newMap };
		}),
    clear: () => set({ directives: new Map(), elements: new Map(), parentDirectives: new Map() })
}));


// --- From: vs-kire/src/analyzer.ts ---
import * as vscode from 'vscode';
import { kireStore, type DirectiveDefinition, type ElementDefinition } from './store';

export async function loadSchemas(): Promise<void> {
    kireStore.getState().clear();

    try {
        // Busca todos os arquivos kire-schema.json em paralelo
        const [workspaceFiles, nodeModuleFiles] = await Promise.all([
            // Arquivos do workspace (exclui node_modules por padrão)
            vscode.workspace.findFiles('**/kire-schema.json', '**/node_modules/**'),
            // Arquivos dentro de node_modules (sem exclusões)
            vscode.workspace.findFiles('**/node_modules/**/kire-schema.json', null)
        ]);

        // Combina e remove duplicados usando Map para preservar ordem
        const uniqueFiles = new Map<string, vscode.Uri>();
        
        // Adiciona workspace files primeiro (mais importantes)
        for (const uri of workspaceFiles) {
            uniqueFiles.set(uri.toString(), uri);
        }
        
        // Adiciona node modules depois
        for (const uri of nodeModuleFiles) {
            const key = uri.toString();
            if (!uniqueFiles.has(key)) {
                uniqueFiles.set(key, uri);
            }
        }

        // Processa arquivos em paralelo com limite de concorrência
        const batchSize = 5;
        const uris = Array.from(uniqueFiles.values());
        
        for (let i = 0; i < uris.length; i += batchSize) {
            const batch = uris.slice(i, i + batchSize);
            await Promise.all(batch.map(loadSchemaFile));
        }
        
    } catch (error) {
        console.error('Error loading Kire schemas:', error);
    }
}

async function loadSchemaFile(uri: vscode.Uri): Promise<void> {
    try {
        const content = await vscode.workspace.fs.readFile(uri);
        const json = JSON.parse(Buffer.from(content).toString('utf8'));
        
        const state = kireStore.getState();
        
        if (json.directives?.length) {
            state.addDirectives(json.directives as DirectiveDefinition[]);
        }
        
        if (json.elements?.length) {
            state.addElements(json.elements as ElementDefinition[]);
        }
        
    } catch (error) {
        console.warn(`Failed to load schema from ${uri.fsPath}:`, 
            error instanceof Error ? error.message : 'Unknown error');
    }
}

// --- From: vs-kire/src/extension.ts ---
import * as vscode from 'vscode';
import { loadSchemas } from './analyzer';
import { KireLanguageFeatures } from './languages/kire';
import { HtmlLanguageFeatures, registerHtmlCommands } from './languages/html';

export async function activate(context: vscode.ExtensionContext) {
    // console.log('Kire extension activated.');

    // Load initial schemas
    await loadSchemas();

    // Watch for schema changes in workspace (ignoring node_modules usually)
    const watcher = vscode.workspace.createFileSystemWatcher('**/kire-schema.json');
    watcher.onDidChange(() => loadSchemas());
    watcher.onDidCreate(() => loadSchemas());
    watcher.onDidDelete(() => loadSchemas());
    context.subscriptions.push(watcher);

    // Command to manually reload
    context.subscriptions.push(vscode.commands.registerCommand('kire.reloadSchemas', async () => {
        await loadSchemas();
        vscode.window.showInformationMessage('Kire schemas reloaded.');
    }));

    // Register Kire Language Features
    context.subscriptions.push(KireLanguageFeatures.register(context));

    context.subscriptions.push(HtmlLanguageFeatures.register(context));

    // Registra comandos adicionais
    registerHtmlCommands(context);
}

export function deactivate() { }

// --- From: vs-kire/src/parser.ts ---
import { Parser } from '../../core/src/parser';
import { kireStore } from './store';
import * as vscode from 'vscode';

export interface ParseError {
    message: string;
    range: vscode.Range;
    severity?: vscode.DiagnosticSeverity;
}

export const parseFile = async (template: string): Promise<ParseError[]> => {
    const store = kireStore.getState();
    
    // Mock Kire object to match what Parser expects
    const kire = {
        getDirective: (name: string) => store.directives.get(name),
        $directives: store.directives
    };

    const parser = new Parser(template, kire as any);
    
    // Run parser
    parser.parse();

    const errors: ParseError[] = [];

    // Check for unclosed directives (items remaining on stack)
    if (parser.stack && parser.stack.length > 0) {
        for (const node of parser.stack) {
             const loc = node.loc;
             // Parser uses 1-based indexing, VS Code uses 0-based
             const startLine = (loc.start.line || 1) - 1;
             const startCol = (loc.start.column || 1) - 1;
             const endLine = (loc.end.line || 1) - 1;
             const endCol = (loc.end.column || 1) - 1;

             const range = new vscode.Range(startLine, startCol, endLine, endCol);
             
             errors.push({
                 message: `Unclosed directive @${node.name}`,
                 range,
                 severity: vscode.DiagnosticSeverity.Error
             });
        }
    }

    return errors;
}


// --- From: vs-kire/src/languages/html.ts ---
import { kireStore } from '@/store';
import * as vscode from 'vscode';
import {
    getLanguageService as getHtmlService,
    type HTMLFormatConfiguration,
    type HoverSettings,
    type DocumentContext
} from 'vscode-html-languageservice';
import { TextDocument } from 'vscode-languageserver-textdocument';

export const htmlLanguageService = getHtmlService();

function toLspDocument(document: vscode.TextDocument) {
    return TextDocument.create(
        document.uri.toString(),
        document.languageId,
        document.version,
        document.getText()
    );
}

function toVsCodeRange(range: { start: { line: number; character: number }; end: { line: number; character: number } }) {
    return new vscode.Range(
        range.start.line,
        range.start.character,
        range.end.line,
        range.end.character
    );
}

function toLspPosition(position: vscode.Position) {
    return { line: position.line, character: position.character };
}

function toLspRange(range: vscode.Range) {
    return {
        start: { line: range.start.line, character: range.start.character },
        end: { line: range.end.line, character: range.end.character }
    };
}

export class HtmlCompletionItemProvider implements vscode.CompletionItemProvider {
    provideCompletionItems(
        document: vscode.TextDocument,
        position: vscode.Position,
        token: vscode.CancellationToken,
        context: vscode.CompletionContext
    ): vscode.ProviderResult<vscode.CompletionItem[] | vscode.CompletionList> {
        const lspDoc = toLspDocument(document);
        const htmlDoc = htmlLanguageService.parseHTMLDocument(lspDoc);

        const completionConfig = {
            hideAutoCompleteProposals: false
        };

        const htmlList = htmlLanguageService.doComplete(
            lspDoc,
            toLspPosition(position),
            htmlDoc,
            completionConfig
        );

        return htmlList.items.map(item => {
            const newItem = new vscode.CompletionItem(item.label);
            newItem.kind = item.kind as unknown as vscode.CompletionItemKind;

            if (item.detail) newItem.detail = item.detail;
            if (item.documentation) {
                newItem.documentation = (typeof item.documentation === 'string'
                    ? new vscode.MarkdownString(item.documentation)
                    : item.documentation) as any;
            }

            newItem.insertText = item.insertText ?
                (typeof item.insertText === 'string' ? item.insertText : (item.insertText as any).value)
                : item.label;

            if (item.filterText) newItem.filterText = item.filterText;
            if (item.sortText) newItem.sortText = item.sortText;
            if (item.preselect !== undefined) newItem.preselect = item.preselect;
            if (item.commitCharacters) newItem.commitCharacters = item.commitCharacters;

            if (item.textEdit) {
                if ('range' in item.textEdit && 'newText' in item.textEdit) {
                    newItem.range = toVsCodeRange(item.textEdit.range);
                    newItem.insertText = item.textEdit.newText;
                }
            }

            if (item.additionalTextEdits) {
                newItem.additionalTextEdits = item.additionalTextEdits.map(edit =>
                    new vscode.TextEdit(toVsCodeRange(edit.range), edit.newText)
                );
            }

            return newItem;
        });
    }
}

export class HtmlHoverProvider implements vscode.HoverProvider {
    provideHover(
        document: vscode.TextDocument,
        position: vscode.Position,
        token: vscode.CancellationToken
    ): vscode.ProviderResult<vscode.Hover> {
        const lspDoc = toLspDocument(document);
        const htmlDoc = htmlLanguageService.parseHTMLDocument(lspDoc);

        const hoverSettings: HoverSettings = {
            documentation: true,
            references: true
        };

        const hover = htmlLanguageService.doHover(
            lspDoc,
            toLspPosition(position),
            htmlDoc,
            hoverSettings
        );

        if (!hover || !hover.contents) {
            return undefined;
        }

        const markdown = new vscode.MarkdownString();
        markdown.isTrusted = true;

        if (typeof hover.contents === 'string') {
            markdown.appendMarkdown(hover.contents);
        } else if (Array.isArray(hover.contents)) {
            hover.contents.forEach((c, index) => {
                if (typeof c === 'string') {
                    markdown.appendMarkdown(c);
                } else if ('language' in c) {
                    markdown.appendCodeblock(c.value, c.language);
                } else {
                    markdown.appendMarkdown((c as any).value);
                }
                if (index < (hover.contents as any[]).length - 1) {
                    markdown.appendText('\n\n');
                }
            });
        } else if ('kind' in hover.contents) {
            if (hover.contents.kind === 'markdown') {
                markdown.appendMarkdown(hover.contents.value);
            } else {
                markdown.appendCodeblock(hover.contents.value, hover.contents.kind || '');
            }
        } else {
            markdown.appendCodeblock(hover.contents.value, hover.contents.language || '');
        }

        const range = hover.range ? toVsCodeRange(hover.range) : undefined;
        return new vscode.Hover(markdown, range);
    }
}

export class HtmlDocumentSymbolProvider implements vscode.DocumentSymbolProvider {
    provideDocumentSymbols(
        document: vscode.TextDocument,
        token: vscode.CancellationToken
    ): vscode.ProviderResult<vscode.DocumentSymbol[] | vscode.SymbolInformation[]> {
        const lspDoc = toLspDocument(document);
        const htmlDoc = htmlLanguageService.parseHTMLDocument(lspDoc);

        // Usa a nova API com DocumentSymbol (hierárquico)
        const documentSymbols = htmlLanguageService.findDocumentSymbols2(lspDoc, htmlDoc);

        if (documentSymbols.length > 0) {
            return documentSymbols.map(s => {
                const range = toVsCodeRange(s.range);
                const selectionRange = toVsCodeRange(s.selectionRange);
                const symbol = new vscode.DocumentSymbol(
                    s.name,
                    s.detail || '',
                    s.kind as unknown as vscode.SymbolKind,
                    range,
                    selectionRange
                );

                if (s.children) {
                    symbol.children = s.children.map(child => {
                        const childRange = toVsCodeRange(child.range);
                        const childSelectionRange = toVsCodeRange(child.selectionRange);
                        return new vscode.DocumentSymbol(
                            child.name,
                            child.detail || '',
                            child.kind as unknown as vscode.SymbolKind,
                            childRange,
                            childSelectionRange
                        );
                    });
                }

                return symbol;
            });
        }

        // Fallback para API antiga
        const symbols = htmlLanguageService.findDocumentSymbols(lspDoc, htmlDoc);
        return symbols.map(s => {
            const range = toVsCodeRange(s.location.range);
            const location = new vscode.Location(vscode.Uri.parse(s.location.uri), range);
            return new vscode.SymbolInformation(
                s.name,
                s.kind as unknown as vscode.SymbolKind,
                s.containerName || '',
                location
            );
        });
    }
}

export class HtmlDocumentHighlightProvider implements vscode.DocumentHighlightProvider {
    provideDocumentHighlights(
        document: vscode.TextDocument,
        position: vscode.Position,
        token: vscode.CancellationToken
    ): vscode.ProviderResult<vscode.DocumentHighlight[]> {
        const lspDoc = toLspDocument(document);
        const htmlDoc = htmlLanguageService.parseHTMLDocument(lspDoc);
        const highlights = htmlLanguageService.findDocumentHighlights(
            lspDoc,
            toLspPosition(position),
            htmlDoc
        );

        return highlights.map(h => {
            const range = toVsCodeRange(h.range);
            let kind = vscode.DocumentHighlightKind.Text;

            switch (h.kind) {
                case 1:
                    kind = vscode.DocumentHighlightKind.Text;
                    break;
                case 2:
                    kind = vscode.DocumentHighlightKind.Read;
                    break;
                case 3:
                    kind = vscode.DocumentHighlightKind.Write;
                    break;
            }

            return new vscode.DocumentHighlight(range, kind);
        });
    }
}

export class HtmlDefinitionProvider implements vscode.DefinitionProvider {
    provideDefinition(
        document: vscode.TextDocument,
        position: vscode.Position,
        token: vscode.CancellationToken
    ): vscode.ProviderResult<vscode.Definition | vscode.LocationLink[]> {
        const lspDoc = toLspDocument(document);
        const htmlDoc = htmlLanguageService.parseHTMLDocument(lspDoc);

        // Para HTML, a definição geralmente é o próprio elemento
        // Se quiser suporte a definições mais avançadas, pode implementar
        return undefined;
    }
}

export class HtmlReferenceProvider implements vscode.ReferenceProvider {
    provideReferences(
        document: vscode.TextDocument,
        position: vscode.Position,
        context: vscode.ReferenceContext,
        token: vscode.CancellationToken
    ): vscode.ProviderResult<vscode.Location[]> {
        const lspDoc = toLspDocument(document);
        const htmlDoc = htmlLanguageService.parseHTMLDocument(lspDoc);

        // Encontra todas as ocorrências do elemento atual
        const highlights = htmlLanguageService.findDocumentHighlights(
            lspDoc,
            toLspPosition(position),
            htmlDoc
        );

        return highlights.map(h => {
            const range = toVsCodeRange(h.range);
            return new vscode.Location(document.uri, range);
        });
    }
}

export class HtmlRenameProvider implements vscode.RenameProvider {
    provideRenameEdits(
        document: vscode.TextDocument,
        position: vscode.Position,
        newName: string,
        token: vscode.CancellationToken
    ): vscode.ProviderResult<vscode.WorkspaceEdit> {
        const lspDoc = toLspDocument(document);
        const htmlDoc = htmlLanguageService.parseHTMLDocument(lspDoc);
        const workspaceEdit = htmlLanguageService.doRename(
            lspDoc,
            toLspPosition(position),
            newName,
            htmlDoc
        );

        if (!workspaceEdit) {
            return undefined;
        }

        const edit = new vscode.WorkspaceEdit();

        if (workspaceEdit.changes) {
            Object.entries(workspaceEdit.changes).forEach(([uri, textEdits]) => {
                edit.set(
                    vscode.Uri.parse(uri),
                    textEdits.map(te => new vscode.TextEdit(toVsCodeRange(te.range), te.newText))
                );
            });
        }

        return edit;
    }
}

export class HtmlFoldingRangeProvider implements vscode.FoldingRangeProvider {
    provideFoldingRanges(
        document: vscode.TextDocument,
        _context: vscode.FoldingContext,
        _token: vscode.CancellationToken
    ): vscode.ProviderResult<vscode.FoldingRange[]> {
        const lspDoc = toLspDocument(document);
        const foldingRanges = htmlLanguageService.getFoldingRanges(lspDoc);

        return foldingRanges.map(range => {
            return new vscode.FoldingRange(
                range.startLine,
                range.endLine,
                range.kind as never
            );
        });
    }
}

export class HtmlSelectionRangeProvider implements vscode.SelectionRangeProvider {
    provideSelectionRanges(
        document: vscode.TextDocument,
        positions: vscode.Position[],
        token: vscode.CancellationToken
    ): vscode.ProviderResult<vscode.SelectionRange[]> {
        const lspDoc = toLspDocument(document);
        const lspPositions = positions.map(p => toLspPosition(p));

        const selectionRanges = htmlLanguageService.getSelectionRanges(lspDoc, lspPositions);

        return selectionRanges.map(range => {
            let current: vscode.SelectionRange | undefined;
            let parent = range;

            while (parent) {
                const vsRange = toVsCodeRange(parent.range);
                current = new vscode.SelectionRange(vsRange, current);
                parent = parent.parent;
            }

            return current!;
        });
    }
}

export class HtmlDiagnosticProvider {
    // HTML void elements (self-closing)
    private readonly htmlVoidElements = new Set([
        'area', 'base', 'br', 'col', 'embed', 'hr',
        'img', 'input', 'link', 'meta', 'param',
        'source', 'track', 'wbr', 'command', 'keygen'
    ]);

    createDiagnostics(document: vscode.TextDocument): vscode.Diagnostic[] {
        const diagnostics: vscode.Diagnostic[] = [];
        const text = document.getText();

        this.validateUnclosedTags(document, text, diagnostics);
        this.validateAttributes(document, text, diagnostics);

        return diagnostics;
    }

    private validateUnclosedTags(document: vscode.TextDocument, text: string, diagnostics: vscode.Diagnostic[]) {
        const stack: Array<{ tag: string, line: number, char: number }> = [];
        const tagRegex = /<(\/?)([a-zA-Z][a-zA-Z0-9_-]*)(?:\s|>|\/)/g;
        const store = kireStore.getState();
        let match: RegExpExecArray | null;
        while ((match = tagRegex.exec(text)) !== null) {
            const isClosing = match[1] === '/';
            const tagName = match[2];
            const position = document.positionAt(match.index);

            // Check if element is void (self-closing)
            let isVoid = this.htmlVoidElements.has(tagName.toLowerCase());
            // kire element check
            if(store.elements.get(tagName)) isVoid = !!store.elements.get(tagName)?.void;

            if (!isClosing && !isVoid) {
                // Only push to stack if NOT void
                stack.push({
                    tag: tagName,
                    line: position.line,
                    char: position.character
                });
            } else if (isClosing) {
                // Handle closing tag
                if (stack.length === 0) {
                    diagnostics.push(new vscode.Diagnostic(
                        new vscode.Range(position, position.translate(0, tagName.length + 2)),
                        `Closing tag </${tagName}> has no corresponding opening tag`,
                        vscode.DiagnosticSeverity.Error
                    ));
                } else {
                    const last = stack[stack.length - 1];
                    
                    if (last.tag !== tagName) {
                        diagnostics.push(new vscode.Diagnostic(
                            new vscode.Range(position, position.translate(0, tagName.length + 2)),
                            `Closing tag </${tagName}> does not match opening tag <${last.tag}>`,
                            vscode.DiagnosticSeverity.Error
                        ));
                        stack.pop();
                    } else {
                        stack.pop(); // Matches correctly
                    }
                }
            }
            
            // Check for void elements with separate closing tag (error)
            if (isVoid && !isClosing) {
                const nextChars = text.substring(match.index, Math.min(match.index + 200, text.length));
                const closingTagPattern = new RegExp(`</${tagName}\\s*>`, 'i');
                const closingMatch = closingTagPattern.exec(nextChars);
                
                if (closingMatch) {
                    const closingPos = document.positionAt(match.index + closingMatch.index);
                    diagnostics.push(new vscode.Diagnostic(
                        new vscode.Range(closingPos, closingPos.translate(0, tagName.length + 3)),
                        `Void element <${tagName}> should not have a separate closing tag`,
                        vscode.DiagnosticSeverity.Error
                    ));
                }
            }
        }

        // Check for unclosed tags at the end
        stack.forEach(({ tag, line, char }) => {
            diagnostics.push(new vscode.Diagnostic(
                new vscode.Range(line, char, line, char + tag.length + 1),
                `Unclosed tag <${tag}>`,
                vscode.DiagnosticSeverity.Warning
            ));
        });
    }

    private validateAttributes(document: vscode.TextDocument, text: string, diagnostics: vscode.Diagnostic[]) {
        // Validate unquoted attribute values
        const unquotedAttrRegex = /\s([a-zA-Z-]+)=([^"'\s>]+)(?=\s|\/?>)/g;
        let match: RegExpExecArray | null;

        while ((match = unquotedAttrRegex.exec(text)) !== null) {
            const attrName = match[1];
            const attrValue = match[2];
            const position = document.positionAt(match.index + match[0].indexOf(attrValue));

            // Check if value needs quotes
            if (attrValue.includes(' ') || attrValue.includes('=') || attrValue.includes('>')) {
                diagnostics.push(new vscode.Diagnostic(
                    new vscode.Range(position, position.translate(0, attrValue.length)),
                    `Attribute "${attrName}" value should be quoted`,
                    vscode.DiagnosticSeverity.Warning
                ));
            }
        }
        
        // Validate empty attribute values
        const emptyAttrRegex = /\s([a-zA-Z-]+)=(?=\s|\/?>)/g;
        while ((match = emptyAttrRegex.exec(text)) !== null) {
            const attrName = match[1];
            const position = document.positionAt(match.index + match[0].indexOf('='));
            
            diagnostics.push(new vscode.Diagnostic(
                new vscode.Range(position, position.translate(0, 1)),
                `Attribute "${attrName}" has empty value`,
                vscode.DiagnosticSeverity.Warning
            ));
        }
    }
}

export class HtmlDocumentLinkProvider implements vscode.DocumentLinkProvider {
    provideDocumentLinks(
        document: vscode.TextDocument,
        _token: vscode.CancellationToken
    ): vscode.ProviderResult<vscode.DocumentLink[]> {
        const lspDoc = toLspDocument(document);

        const documentContext: DocumentContext = {
            resolveReference: (ref, _base) => {
                // Implementação básica de resolução de referência
                if (ref.startsWith('/')) {
                    return vscode.Uri.joinPath(vscode.workspace.workspaceFolders?.[0]?.uri || document.uri, ref).toString();
                }
                return ref;
            }
        };

        const documentLinks = htmlLanguageService.findDocumentLinks(lspDoc, documentContext);

        return documentLinks.map(link => {
            const range = toVsCodeRange(link.range);
            const target = link.target ? vscode.Uri.parse(link.target) : undefined;
            return new vscode.DocumentLink(range, target);
        });
    }
}

export class HtmlFormattingProvider implements vscode.DocumentFormattingEditProvider {
    provideDocumentFormattingEdits(
        document: vscode.TextDocument,
        options: vscode.FormattingOptions,
        token: vscode.CancellationToken
    ): vscode.ProviderResult<vscode.TextEdit[]> {
        const lspDoc = toLspDocument(document);

        const htmlFormatConfig: HTMLFormatConfiguration = {
            tabSize: options.tabSize,
            insertSpaces: options.insertSpaces,
            wrapLineLength: 120,
            unformatted: '',
            contentUnformatted: 'pre,code,textarea',
            indentInnerHtml: true,
            preserveNewLines: true,
            maxPreserveNewLines: options.insertSpaces ? undefined : 1,
            indentHandlebars: false,
            endWithNewline: false,
            extraLiners: 'head, body, /html',
            wrapAttributes: 'auto'
        };

        const textEdits = htmlLanguageService.format(
            lspDoc,
            undefined, // Range completo
            htmlFormatConfig
        );

        return textEdits.map(edit =>
            new vscode.TextEdit(toVsCodeRange(edit.range), edit.newText)
        );
    }
}

export class HtmlRangeFormattingProvider implements vscode.DocumentRangeFormattingEditProvider {
    provideDocumentRangeFormattingEdits(
        document: vscode.TextDocument,
        range: vscode.Range,
        options: vscode.FormattingOptions,
        token: vscode.CancellationToken
    ): vscode.ProviderResult<vscode.TextEdit[]> {
        const lspDoc = toLspDocument(document);

        const htmlFormatConfig: HTMLFormatConfiguration = {
            tabSize: options.tabSize,
            insertSpaces: options.insertSpaces,
            wrapLineLength: 120,
            unformatted: '',
            contentUnformatted: 'pre,code,textarea',
            indentInnerHtml: true,
            preserveNewLines: true,
            maxPreserveNewLines: options.insertSpaces ? undefined : 1
        };

        const textEdits = htmlLanguageService.format(
            lspDoc,
            toLspRange(range),
            htmlFormatConfig
        );

        return textEdits.map(edit =>
            new vscode.TextEdit(toVsCodeRange(edit.range), edit.newText)
        );
    }
}

// Extensão para encontrar tags correspondentes
export class HtmlMatchingTagProvider {
    async findMatchingTagPosition(
        document: vscode.TextDocument,
        position: vscode.Position
    ): Promise<vscode.Position | null> {
        const lspDoc = toLspDocument(document);
        const htmlDoc = htmlLanguageService.parseHTMLDocument(lspDoc);
        const match = htmlLanguageService.findMatchingTagPosition(
            lspDoc,
            toLspPosition(position),
            htmlDoc
        );

        if (match) {
            return new vscode.Position(match.line, match.character);
        }

        return null;
    }
}

// Extensão para linked editing (renomear tag de abertura/fechamento juntas)
export class HtmlLinkedEditingProvider {
    provideLinkedEditingRanges(
        document: vscode.TextDocument,
        position: vscode.Position
    ): vscode.Range[] | null {
        const lspDoc = toLspDocument(document);
        const htmlDoc = htmlLanguageService.parseHTMLDocument(lspDoc);
        const ranges = htmlLanguageService.findLinkedEditingRanges(
            lspDoc,
            toLspPosition(position),
            htmlDoc
        );

        if (ranges) {
            return ranges.map(r => toVsCodeRange(r));
        }

        return null;
    }
}

// Classe principal para registrar todos os providers
// biome-ignore lint/complexity/noStaticOnlyClass: ignore
export class HtmlLanguageFeatures {
    static register(context: vscode.ExtensionContext): vscode.Disposable {
        const disposables: vscode.Disposable[] = [];

        // Registra os providers principais
        const providers = [
            vscode.languages.registerCompletionItemProvider(
                { language: 'kire' },
                new HtmlCompletionItemProvider(),
                '<', ' ', '"', "'", '=', '/', ':'
            ),
            vscode.languages.registerHoverProvider(
                { language: 'kire' },
                new HtmlHoverProvider()
            ),
            vscode.languages.registerDocumentSymbolProvider(
                { language: 'kire' },
                new HtmlDocumentSymbolProvider()
            ),
            vscode.languages.registerDocumentHighlightProvider(
                { language: 'kire' },
                new HtmlDocumentHighlightProvider()
            ),
            vscode.languages.registerReferenceProvider(
                { language: 'kire' },
                new HtmlReferenceProvider()
            ),
            vscode.languages.registerRenameProvider(
                { language: 'kire' },
                new HtmlRenameProvider()
            ),
            vscode.languages.registerFoldingRangeProvider(
                { language: 'kire' },
                new HtmlFoldingRangeProvider()
            ),
            vscode.languages.registerSelectionRangeProvider(
                { language: 'kire' },
                new HtmlSelectionRangeProvider()
            ),
            vscode.languages.registerDocumentLinkProvider(
                { language: 'kire' },
                new HtmlDocumentLinkProvider()
            ),
            vscode.languages.registerDocumentFormattingEditProvider(
                { language: 'kire' },
                new HtmlFormattingProvider()
            ),
            vscode.languages.registerDocumentRangeFormattingEditProvider(
                { language: 'kire' },
                new HtmlRangeFormattingProvider()
            )
        ];

        disposables.push(...providers);

        // Configura diagnósticos
        const diagnosticProvider = new HtmlDiagnosticProvider();
        const diagnosticCollection = vscode.languages.createDiagnosticCollection('html');
        disposables.push(diagnosticCollection);

        // Atualiza diagnósticos
        const updateDiagnostics = (document: vscode.TextDocument) => {
            if (document.languageId === 'kire') {
                const diagnostics = diagnosticProvider.createDiagnostics(document);
                diagnosticCollection.set(document.uri, diagnostics);
            }
        };

        disposables.push(
            vscode.workspace.onDidChangeTextDocument(e => updateDiagnostics(e.document)),
            vscode.workspace.onDidOpenTextDocument(updateDiagnostics),
            vscode.workspace.onDidCloseTextDocument(doc => diagnosticCollection.delete(doc.uri))
        );

        // Inicializa diagnósticos para documentos abertos
        vscode.workspace.textDocuments.forEach(updateDiagnostics);

        return vscode.Disposable.from(...disposables);
    }
}

// Comandos adicionais úteis
export function registerHtmlCommands(context: vscode.ExtensionContext) {
    const matchingTagProvider = new HtmlMatchingTagProvider();

    const goToMatchingTag = vscode.commands.registerCommand('kire.goToMatchingTag', async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor || editor.document.languageId !== 'kire') {
            return;
        }

        const position = editor.selection.active;
        const match = await matchingTagProvider.findMatchingTagPosition(editor.document, position);

        if (match) {
            editor.selection = new vscode.Selection(match, match);
            editor.revealRange(new vscode.Range(match, match));
        } else {
            vscode.window.showInformationMessage('No matching tag found');
        }
    });

    context.subscriptions.push(goToMatchingTag);
}

// --- From: vs-kire/src/languages/kire.ts ---
import * as vscode from 'vscode';
import { kireStore } from '../store';
import { parseFile } from '../parser';

// Semantic Tokens Legend
const tokenTypes = ['keyword', 'class', 'type', 'parameter', 'variable', 'property'];
const tokenModifiers = ['declaration', 'documentation'];
export const semanticTokensLegend = new vscode.SemanticTokensLegend(tokenTypes, tokenModifiers);

export class KireCompletionItemProvider implements vscode.CompletionItemProvider {
    provideCompletionItems(document: vscode.TextDocument, position: vscode.Position, _token: vscode.CancellationToken, context: vscode.CompletionContext): vscode.ProviderResult<vscode.CompletionItem[] | vscode.CompletionList> {
        const items: vscode.CompletionItem[] = [];
        const char = context.triggerCharacter;
        const linePrefix = document.lineAt(position).text.substr(0, position.character);

        // 1. Triggered by '<' -> Elements
        if (char === '<' || linePrefix.endsWith('<')) {
            kireStore.getState().elements.forEach((def) => {
                const item = new vscode.CompletionItem(def.name, vscode.CompletionItemKind.Class);
                item.detail = "Kire Element";
                item.documentation = new vscode.MarkdownString(def.description || '');
                if (def.void) {
                     item.insertText = new vscode.SnippetString(`${def.name} $0>`);
                } else {
                     item.insertText = new vscode.SnippetString(`${def.name}>$0</${def.name}>`);
                }
                items.push(item);
            });
        }

        // 2. Triggered by '@' -> Directives
        if (char === '@' || linePrefix.endsWith('@')) {
            if (linePrefix.endsWith('@@')) return []; // Escaped

            kireStore.getState().directives.forEach((def) => {
                const item = new vscode.CompletionItem(def.name, vscode.CompletionItemKind.Keyword);
                item.detail = `Kire Directive (${def.type || 'general'})`;
                item.documentation = new vscode.MarkdownString(def.description || '');
                
                let snippet = def.name;
                if (def.params && def.params.length > 0) {
                     snippet += '(';
                     snippet += def.params.map((p, i) => `\${${i+1}:${p.split(':')[0]}}`).join(', ');
                     snippet += ')';
                }
                
                if (def.children) {
                    snippet += "\n\t$0\n@end";
                }
                
                item.insertText = new vscode.SnippetString(snippet);
                items.push(item);
            });
            
            if (!kireStore.getState().directives.has('end')) {
                const endItem = new vscode.CompletionItem('end', vscode.CompletionItemKind.Keyword);
                endItem.documentation = "Closes the current directive block.";
                items.push(endItem);
            }
        }

        return items;
    }
}

export class KireHoverProvider implements vscode.HoverProvider {
    provideHover(document: vscode.TextDocument, position: vscode.Position, _token: vscode.CancellationToken): vscode.ProviderResult<vscode.Hover> {
        const range = document.getWordRangeAtPosition(position, /(@?[a-zA-Z0-9_\-:]+)/);
        if (!range) return undefined;

        const word = document.getText(range);

        // Directive
        if (word.startsWith('@')) {
            const directiveName = word.substring(1);
            const def = kireStore.getState().directives.get(directiveName);
            if (def) {
                const md = new vscode.MarkdownString();
                md.appendCodeblock(`@${def.name}${def.params ? `(${def.params.join(', ')})` : ''}`, 'kire');
                if (def.description) md.appendMarkdown(`\n\n${def.description}`);
                return new vscode.Hover(md);
            }
        } 
        
        // Element
        const elementDef = kireStore.getState().elements.get(word);
        if (elementDef) {
             const line = document.lineAt(position.line).text;
             const preceding = line.substring(0, range.start.character);
             if (/<(\/)?\s*$/.test(preceding)) {
                 const md = new vscode.MarkdownString();
                 md.appendCodeblock(`<${elementDef.name}>`, 'html');
                 if (elementDef.description) md.appendMarkdown(`\n\n${elementDef.description}`);
                 return new vscode.Hover(md);
             }
        }
        
        return undefined;
    }
}

export class KireDocumentSymbolProvider implements vscode.DocumentSymbolProvider {
    provideDocumentSymbols(document: vscode.TextDocument, _token: vscode.CancellationToken): vscode.ProviderResult<vscode.SymbolInformation[] | vscode.DocumentSymbol[]> {
        const symbols: vscode.DocumentSymbol[] = [];
        const text = document.getText();
        const lines = text.split('\n');
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            const dirMatch = /@([a-zA-Z0-9_]+)/.exec(line);
            if (dirMatch) {
                const dirName = dirMatch[1];
                if (dirName !== 'end') {
                    const range = new vscode.Range(i, dirMatch.index, i, dirMatch.index + dirMatch[0].length);
                    symbols.push(new vscode.DocumentSymbol(
                        dirName, 'Directive', vscode.SymbolKind.Function, range, range
                    ));
                }
            }
        }
        return symbols;
    }
}

export class KireSemanticTokensProvider implements vscode.DocumentSemanticTokensProvider {
    provideDocumentSemanticTokens(
        document: vscode.TextDocument,
        _token: vscode.CancellationToken
    ): vscode.ProviderResult<vscode.SemanticTokens> {
        const builder = new vscode.SemanticTokensBuilder(semanticTokensLegend);
        const text = document.getText();
        
        // Regex for directives: @directive
        const directiveRegex = /@([a-zA-Z0-9_-]+)/g;
        
        // Regex for elements: <Element> or </Element>
        const elementRegex = /<\/?([a-zA-Z0-9_-]+)/g;

        let match:RegExpExecArray;

        // Find Directives
        while ((match = directiveRegex.exec(text))) {
            const startPos = document.positionAt(match.index);
            const value = match[0]; // Includes @
            builder.push(
                startPos.line,
                startPos.character,
                value.length,
                0, // index of 'keyword' in tokenTypes
                0
            );
        }

        // Find Elements
        while ((match = elementRegex.exec(text))) {
            const fullMatch = match[0];
            const tagName = match[1];
            const startOffset = match.index + (fullMatch.startsWith('</') ? 2 : 1);
            const startPos = document.positionAt(startOffset);
            
            if (kireStore.getState().elements.has(tagName)) {
                builder.push(
                    startPos.line,
                    startPos.character,
                    tagName.length,
                    1, // index of 'class' in tokenTypes
                    0
                );
            }
        }

        return builder.build();
    }
}

// biome-ignore lint/complexity/noStaticOnlyClass: ignore not need
export class KireLanguageFeatures {
    static register(_context: vscode.ExtensionContext): vscode.Disposable {
        const disposables: vscode.Disposable[] = [];
        const selector = [{ language: 'kire', scheme: 'file' }, { language: 'html', scheme: 'file', pattern: '**/*.kire' }];

        // Register Providers
        disposables.push(
            vscode.languages.registerCompletionItemProvider(selector, new KireCompletionItemProvider(), '@', '<', '{'),
            vscode.languages.registerHoverProvider(selector, new KireHoverProvider()),
            vscode.languages.registerDocumentSymbolProvider(selector, new KireDocumentSymbolProvider()),
            vscode.languages.registerDocumentSemanticTokensProvider(selector, new KireSemanticTokensProvider(), semanticTokensLegend)
        );

        // Diagnostics
        const collection = vscode.languages.createDiagnosticCollection('kire');
        disposables.push(collection);

        async function validateDocument(document: vscode.TextDocument) {
            if (document.languageId !== 'kire' && !document.fileName.endsWith('.kire')) {
                return;
            }
            
            try {
                const errors = await parseFile(document.getText());
                const diagnostics = errors.map(e => {
                    const diag = new vscode.Diagnostic(e.range, e.message, e.severity || vscode.DiagnosticSeverity.Error);
                    diag.source = 'kire';
                    return diag;
                });
                collection.set(document.uri, diagnostics);
            } catch (err) {
                console.error('Error validating Kire document:', err);
            }
        }

        if (vscode.window.activeTextEditor) {
            validateDocument(vscode.window.activeTextEditor.document);
        }

        disposables.push(
            vscode.window.onDidChangeActiveTextEditor(editor => {
                if (editor) {
                    validateDocument(editor.document);
                }
            }),
            vscode.workspace.onDidChangeTextDocument(e => {
                validateDocument(e.document);
            }),
            vscode.workspace.onDidSaveTextDocument(document => {
                validateDocument(document);
            })
        );

        return vscode.Disposable.from(...disposables);
    }
}


