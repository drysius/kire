// Combined source for @kirejs/assets

// --- From: packages/assets/src/types.ts ---
declare module "kire" {
	export interface KireElementContext {
		_assets: {
			scripts: string[];
			styles: string[];
		};
	}
}


// --- From: packages/assets/src/index.ts ---
import { createHash } from "node:crypto";
import type { Kire, KirePlugin } from "kire";

export interface KireAsset {
	hash: string;
	content: string;
	type: "js" | "css" | "mjs";
}

interface KireAssetsOptions {
	prefix?: string;
	domain?: string;
}

// Extend KireContext to include our assets collection
declare module "kire" {
	interface KireContext {
		_assets?: {
			scripts: string[]; // List of hashes
			styles: string[]; // List of hashes
		};
	}
}

export const KireAssets: KirePlugin<KireAssetsOptions> = {
	name: "@kirejs/assets",
	sort: 200,
	options: {
		prefix: "_kire",
	},
	load(kire: Kire, opts) {
		const prefix = opts?.prefix || "_kire";
		console.log(`[KireAssets] Loaded with prefix: ${prefix}`);
		const domain = opts?.domain || "";
		const injectionTag = "kire-assets-injection-point";
		const MAX_CACHE_SIZE = 500;

		const addToCache = (
			cache: Map<string, KireAsset>,
			key: string,
			value: KireAsset,
		) => {
			if (cache.has(key)) return;
			if (cache.size >= MAX_CACHE_SIZE) {
				const firstKey = cache.keys().next().value;
				if (firstKey) cache.delete(firstKey);
			}
			cache.set(key, value);
		};

		// 1. Register handlers for script and style tags to capture inline content
		// Important: Register these BEFORE the injection tag handler so they run first

		// Handle <style>
		kire.element({
			name: "style",
			description: "Captures inline styles to be injected via @assets.",
			example: "<style>body { color: red; }</style>",
			onCall(ctx) {
				if (ctx.element.attributes.nocache !== undefined) return;
				const content = ctx.element.inner;
				if (!content.trim()) return;

				// Generate hash
				const hash = createHash("md5")
					.update(content)
					.digest("hex")
					.slice(0, 8);

				// Get fresh cache reference
				const cache = kire.cached<KireAsset>("@kirejs/assets");

				// Store in global cache
				addToCache(cache, hash, { hash, content, type: "css" });

				// Add to request context
				if (ctx._assets) {
					ctx._assets.styles.push(hash);
					// Remove the original tag
					ctx.replace("");
				}
			},
		});

		// Handle <script>
		kire.element({
			name: "script",
			description: "Captures inline scripts to be injected via @assets.",
			example: "<script>console.log('hello');</script>",
			onCall(ctx) {
				// Check if it's an inline script (no src attribute)
				if (
					ctx.element.attributes.src ||
					ctx.element.attributes.nocache !== undefined
				)
					return;

				const content = ctx.element.inner;
				if (!content.trim()) return;

				const hash = createHash("md5")
					.update(content)
					.digest("hex")
					.slice(0, 8);

				let type: "js" | "mjs" = "js";
				if (
					ctx.element.attributes.type === "module" ||
					content.includes("import ") ||
					content.includes("export ") ||
					content.includes("import.")
				) {
					type = "mjs";
				}

				const cache = kire.cached<KireAsset>("@kirejs/assets");

				addToCache(cache, hash, { hash, content, type });

				if (ctx._assets) {
					ctx._assets.scripts.push(hash);
					ctx.replace("");
				}
			},
		});

		// 2. Register directive @assets()
		kire.directive({
			name: "assets",
			description:
				"Injects the assets placeholder where scripts and styles will be output.",
			example: "@assets()",
			onCall(ctx) {
				// Initialize the assets collection for this request
				ctx.pre(`$ctx._assets = { scripts: [], styles: [] };`);
				// Output the placeholder tag
				ctx.raw(`$ctx.res('<${injectionTag}></${injectionTag}>');`);
			},
		});

		// 3. Register handler for the injection point
		kire.element({
			name: injectionTag,
			description: "Internal placeholder for assets injection.",
			example: "<!-- Internal Use -->",
			onCall(ctx) {
				if (!ctx._assets) {
					ctx.replace("");
					return;
				}

				let output = "";
				const baseUrl = domain ? `${domain}/${prefix}` : `/${prefix}`;
				const cache = kire.cached<KireAsset>("@kirejs/assets");

				// Generate links for styles
				// Use Set to avoid duplicates if any
				const uniqueStyles = [...new Set(ctx._assets.styles)];
				for (const hash of uniqueStyles) {
					output += `<link rel="stylesheet" href="${baseUrl}/${hash}.css" />\n`;
				}

				// Generate scripts
				const uniqueScripts = [...new Set(ctx._assets.scripts)];
				for (const hash of uniqueScripts) {
					const asset = cache.get(hash);
					if (asset && asset.type === "mjs") {
						output += `<script type="module" src="${baseUrl}/${hash}.mjs"></script>\n`;
					} else {
						output += `<script src="${baseUrl}/${hash}.js" defer></script>\n`;
					}
				}

				ctx.replace(output);
			},
		});
	},
};

function getAssetFromPath(
	kire: Kire,
	path: string,
): { content: string; type: "js" | "css" | "mjs" } | null {
	// Validate path and extract hash/type
	// Ensures path ends with /hash.ext to prevent directory traversal
	const match = path.match(/\/([a-f0-9]{8})\.(js|css|mjs)$/);
	if (!match) return null;

	const hash = match[1];
	const ext = match[2] as "js" | "css" | "mjs";

	const cache = kire.cached<KireAsset>("@kirejs/assets");
	const asset = cache.get(hash!);
	if (asset && asset.type === ext) {
		return { content: asset.content, type: ext };
	}
	return null;
}

export const createKireFS = (kire: Kire) => ({
	// Express middleware
	express: (req: any, res: any, next: any) => {
		const asset = getAssetFromPath(kire, req.path || req.url);
		if (asset) {
			res.setHeader(
				"Content-Type",
				asset.type === "css" ? "text/css" : "application/javascript",
			);
			res.setHeader("Cache-Control", "public, max-age=31536000, immutable");
			return res.send(asset.content);
		}
		next();
	},

	// Fastify handler
	fastify: async (req: any, reply: any) => {
		const asset = getAssetFromPath(kire, req.raw.url || req.url);
		if (asset) {
			reply.header(
				"Content-Type",
				asset.type === "css" ? "text/css" : "application/javascript",
			);
			reply.header("Cache-Control", "public, max-age=31536000, immutable");
			return reply.send(asset.content);
		}
		// Fallback for Fastify route handler if not found
		return reply.code(404).send("Not Found");
	},

	// Hono middleware
	hono: async (c: any, next: any) => {
		const asset = getAssetFromPath(kire, c.req.path);
		if (asset) {
			c.header(
				"Content-Type",
				asset.type === "css" ? "text/css" : "application/javascript",
			);
			c.header("Cache-Control", "public, max-age=31536000, immutable");
			return c.body(asset.content);
		}
		await next();
	},

	// Elysia handler
	elysia: (context: any) => {
		const asset = getAssetFromPath(kire, context.path);
		if (asset) {
			context.set.headers["Content-Type"] =
				asset.type === "css" ? "text/css" : "application/javascript";
			context.set.headers["Cache-Control"] =
				"public, max-age=31536000, immutable";
			return asset.content;
		}
	},
});

export default KireAssets;


