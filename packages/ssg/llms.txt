// Combined source for @kirejs/ssg

// --- From: packages/ssg/src/types.ts ---
import type { Kire } from "kire";

export interface SsgBuilder {
	routes: string[];
	add: (path: string, content: string) => Promise<void>;
	rem: (path: string) => Promise<void>;
}

export interface SsgOptions {
	assetsPrefix?: string;
	routes?: string;
	public?: string;
	poshandler?: (builder: SsgBuilder) => void | Promise<void>;
}

export interface BuildOptions {
	out: string;
	dir?: string; // Source directory relative to root, defaults to root
}

export interface SsgState {
    options: SsgOptions;
    dynamicRoutesMap: Map<string, any[]>;
    fileAccessHistory: Array<{
        file: string;
        timestamp: Date;
        type: 'read' | 'write' | 'compile' | 'cache';
        duration?: number;
    }>;
    routeCompilationChain: Map<string, string[]>;
    currentRoute: string | null;
}

// Global reference to the active Kire instance for static methods (build/dev)
export let activeKire: Kire | null = null;

export function setActiveKire(kire: Kire) {
    activeKire = kire;
}

// --- From: packages/ssg/src/utils.ts ---
import { readdir } from "node:fs/promises";
import { resolve } from "node:path";
import type { Kire } from "kire";
import type { SsgState } from "./types";

// Helper to get SSG state from Kire cache Map
export function getSsgState(kire: Kire): SsgState {
    const state = kire.cached<SsgState>("@kirejs/ssg").get("ROOT");
    if (!state) throw new Error("SSG State not initialized in Kire cache. Make sure the plugin is loaded.");
    return state;
}

// Helper to crawl
export async function getFiles(dir: string): Promise<string[]> {
	try {
		const dirents = await readdir(dir, { withFileTypes: true });
		const files = await Promise.all(
			dirents.map(async (dirent) => {
				const res = resolve(dir, dirent.name);
				if (dirent.isDirectory()) {
					return getFiles(res);
				} else {
					return res;
				}
			}),
		);
		return Array.prototype.concat(...files);
	} catch (e) {
		return [];
	}
}

// Create a proxy to track file accesses
export function trackFileAccess(kire: Kire) {
	const originalCacheGet = kire.$files.get;
	const originalCacheSet = kire.$files.set;
	const originalCacheClear = kire.$files.clear;
	
	kire.$files.get = function(key: string) {
		const start = Date.now();
		const result = originalCacheGet.call(this, key);
		const duration = Date.now() - start;
		
        try {
            const state = getSsgState(kire);
            state.fileAccessHistory.push({
                file: key,
                timestamp: new Date(),
                type: 'cache',
                duration
            });
            
            if (state.currentRoute && !state.routeCompilationChain.has(state.currentRoute)) {
                state.routeCompilationChain.set(state.currentRoute, []);
            }
            if (state.currentRoute && !state.routeCompilationChain.get(state.currentRoute)?.includes(key)) {
                state.routeCompilationChain.get(state.currentRoute)?.push(key);
            }
        } catch(e) {}
		
		return result;
	};
	
	kire.$files.set = function(key: string, value: any) {
        try {
            const state = getSsgState(kire);
            state.fileAccessHistory.push({
                file: key,
                timestamp: new Date(),
                type: 'write'
            });
        } catch(e) {}
		return originalCacheSet.call(this, key, value);
	};
	
	kire.$files.clear = function() {
        try {
            const state = getSsgState(kire);
            state.fileAccessHistory.length = 0;
            state.routeCompilationChain.clear();
        } catch(e) {}
		return originalCacheClear.call(this);
	};
	
	// Track view compilation
	const originalView = kire.view.bind(kire);
	kire.view = async (template: string, data?: any) => {
        let state: SsgState | null = null;
        try { state = getSsgState(kire); } catch(e) {}

        if (!state) return originalView(template, data);

		const prevRoute = state.currentRoute;
		state.currentRoute = template;
		const start = Date.now();
		
		try {
			state.fileAccessHistory.push({
				file: template,
				timestamp: new Date(),
				type: 'compile'
			});
			
			state.routeCompilationChain.set(template, [template]);
			
			const result = await originalView(template, data);
			const duration = Date.now() - start;
			
			const lastEntry = state.fileAccessHistory[state.fileAccessHistory.length - 1];
			if (lastEntry && lastEntry.file === template) {
				lastEntry.duration = duration;
			}
			
			return result;
		} finally {
			state.currentRoute = prevRoute;
		}
	};
}

// --- From: packages/ssg/src/dev.ts ---
import { watch } from "node:fs";
import { createServer, type ServerResponse } from "node:http";
import { join, relative, resolve } from "node:path";
import type { KireAsset } from "@kirejs/assets";
import { renderErrorPage } from "./error-page";
import { Logger, colors } from "./logger";
import { getFiles, getSsgState } from "./utils";
import { activeKire, type SsgBuilder, type SsgState } from "./types";

const devGeneratedFiles = new Map<string, string>();

export async function dev(opts: { port?: number } = {}) {
    const kireInstance = activeKire;
    if (!kireInstance) throw new Error("KireSsg plugin not registered.");

    const state = getSsgState(kireInstance);
    const pluginOptions = state.options;

    const port = opts.port || 3000;
    const clients: ServerResponse[] = [];
    const rootDir = resolve(kireInstance.root);
    const routesDir = resolve(rootDir, pluginOptions.routes || ".");
    const assetsPrefix = pluginOptions.assetsPrefix || "_kire";

    async function scanRoutes(): Promise<string[]> {
        const ext = kireInstance!.extension.startsWith(".")
            ? kireInstance!.extension
            : `.${kireInstance!.extension}`;
        
        const files = await getFiles(routesDir);
        const routes: string[] = [];
        
        for (const file of files) {
            if (!file.endsWith(ext)) continue;
            const relativePath = relative(routesDir, file);
            if (relativePath.split("/").some((p) => p.startsWith("_"))) continue;
            
            const nameWithoutExt = relativePath.slice(0, -ext.length);
            let routeUrl = "";
            if (nameWithoutExt === "index" || nameWithoutExt.endsWith("/index")) {
                routeUrl = nameWithoutExt.replace(/\/index$/, "") || "index";
            } else {
                routeUrl = nameWithoutExt;
            }
            routes.push(routeUrl === "index" ? "/" : "/" + routeUrl);
        }
        return routes;
    }

    if (pluginOptions.poshandler) {
        const routes = await scanRoutes();
        const builder: SsgBuilder = {
            routes,
            add: async (path: string, content: string) => {
                devGeneratedFiles.set(path, content);
                devGeneratedFiles.set("/" + path, content);
                Logger.info(`[DEV] Generated in-memory file: ${path}`);
            },
            rem: async (path: string) => {
                devGeneratedFiles.delete(path);
                devGeneratedFiles.delete("/" + path);
            }
        };
        await pluginOptions.poshandler(builder);
    }

    let fsWait: Timer | boolean = false;
    watch(rootDir, { recursive: true }, (_event, filename) => {
        if (filename) {
            if (fsWait) return;
            fsWait = setTimeout(() => {
                fsWait = false;
            }, 100);

            Logger.info(`File changed: ${filename}. Reloading...`);
            kireInstance!.cacheClear();

            clients.forEach(res => {
                res.write(`data: reload\n\n`);
            });
            
            if (pluginOptions.poshandler) {
                scanRoutes().then(routes => {
                    const builder: SsgBuilder = {
                        routes,
                        add: async (path, content) => {
                            devGeneratedFiles.set(path, content);
                            devGeneratedFiles.set("/" + path, content);
                        },
                        rem: async (path) => {
                            devGeneratedFiles.delete(path);
                            devGeneratedFiles.delete("/" + path);
                        }
                    };
                    pluginOptions.poshandler!(builder);
                });
            }
        }
    });

    const server = createServer(async (req, res) => {
        const url = req.url || "/";
        const start = Date.now();

        if (url === "/kire-livereload") {
            res.writeHead(200, {
                "Content-Type": "text/event-stream",
                "Cache-Control": "no-cache",
                "Connection": "keep-alive",
            });
            res.write("data: connected\n\n");
            clients.push(res);

            req.on("close", () => {
                const idx = clients.indexOf(res);
                if (idx !== -1) clients.splice(idx, 1);
            });
            return;
        }

        try {
            const cleanPath = url.split('?')[0]!;
            if (devGeneratedFiles.has(cleanPath)) {
                const content = devGeneratedFiles.get(cleanPath)!;
                res.setHeader("Content-Type", cleanPath.endsWith(".xml") ? "application/xml" : "text/plain");
                res.end(content);
                Logger.request(req.method!, url, 200, Date.now() - start);
                return;
            }

            const prefixPath = `/${assetsPrefix}/`;
            if (url.startsWith(prefixPath)) {
                const match = url.match(/\/([a-f0-9]{8})\.(js|css|mjs)$/);
                if (match) {
                    const hash = match[1];
                    const ext = match[2] as "js" | "css" | "mjs";
                    const assetsCache = kireInstance!.cached<KireAsset>("@kirejs/assets");
                    const asset = assetsCache.get(hash!);
                    if (asset && asset.type === ext) {
                        res.setHeader(
                            "Content-Type",
                            ext === "css" ? "text/css" : "application/javascript",
                        );
                        res.end(asset.content);
                        Logger.request(req.method!, url, 200, Date.now() - start);
                        return;
                    } else {
                        const keys = Array.from(assetsCache.keys());
                        Logger.warn(`[DEV] Asset 404. Hash: ${hash}. Cache has ${keys.length} items: ${keys.join(', ')}`);
                    }
                }
                res.statusCode = 404;
                res.end("Asset Not Found");
                Logger.request(req.method!, url, 404, Date.now() - start);
                return;
            }

            let cleanUrl = url.split('?')[0];
            if (cleanUrl?.endsWith("/")) cleanUrl = cleanUrl.slice(0, -1);
            if (!cleanUrl) cleanUrl = "index";
            else cleanUrl = cleanUrl.substring(1); 
            
            const candidates = [
                cleanUrl,
                `${cleanUrl}/index`,
            ];
            
            const routesRelPath = pluginOptions.routes || ".";
            const ext = kireInstance!.extension.startsWith(".") ? kireInstance!.extension : `.${kireInstance!.extension}`;

            let html: string | null | undefined = null;
            let servedCandidate = "";
            let params: Record<string, string> = {};

            for (const candidate of candidates) {
                try {
                    const kirePath = join(routesRelPath, candidate);
                    html = await kireInstance?.view(kirePath, { $params: {} });
                    servedCandidate = kirePath;
                    break;
                } catch (e: any) {
                    if (
                        e.message.includes("No resolver") ||
                        e.message.includes("ENOENT") ||
                        e.message.includes("Template not found")
                    ) {
                        continue;
                    }
                    throw e;
                }
            }

            if (html === null) {
                const allFiles = await getFiles(routesDir);
                const dynamicTemplates = allFiles.filter(f => f.includes('[') && f.endsWith(ext));

                for (const template of dynamicTemplates) {
                    const relTemplatePath = relative(routesDir, template);
                    const match = relTemplatePath.match(/\[([^\]]+)\]/);
                    const paramName = match ? match[1] : null;

                    if (paramName) {
                        // Create regex from template path: packages.[package].kire -> ^packages/([^/]+)/?$
                        const pattern = relTemplatePath
                            .slice(0, -ext.length)
                            .replace(`[${paramName}]`, "([^/]+)")
                            .replace(/\.$/, "") // Remove trailing dot if it was before [param]
                            .replace(/\\/g, '/'); // Normalize slashes for regex
                        
                        const regex = new RegExp(`^${pattern}/?$`);
                        const urlMatch = cleanUrl.match(regex);

                        if (urlMatch) {
                            params[paramName] = urlMatch[1]!;
                            
                            const kirePath = join(routesRelPath, relTemplatePath.slice(0, -ext.length)); // View expects path without ext? No, view expects relative path usually with ext or resolved.
                            // Kire view needs path relative to root? Or resolved?
                            // In build.ts: kireInstance.view(kireResolvePath, ...)
                            // Here kirePath is relative to routesDir.
                            // Let's pass the full relative path from root.
                            const rootRelPath = relative(rootDir, template);
                            
                            html = await kireInstance?.view(rootRelPath, { $params: params });
                            servedCandidate = rootRelPath;
                            break;
                        }
                    }
                }
            }

            if (html !== null) {
                res.setHeader("Content-Type", "text/html");

                const liveReloadScript = `
                    <script>
                        (() => {
                            const evtSource = new EventSource("/kire-livereload");
                            evtSource.onmessage = (event) => {
                                if (event.data === "reload") {
                                    window.location.reload();
                                }
                            };
                        })();
                    </script>
                `;

                if (html!.includes("</body>")) {
                    html = html!.replace("</body>", `${liveReloadScript}</body>`);
                } else {
                    html += liveReloadScript;
                }

                res.end(html);
                Logger.request(req.method!, url, 200, Date.now() - start);
            } else {
                try {
                    const notFoundPath = join(routesRelPath, "_not_found");
                    let notFoundHtml = await kireInstance?.view(notFoundPath);
                    
                    if (notFoundHtml) {
                        res.statusCode = 404;
                        res.setHeader("Content-Type", "text/html");

                        const liveReloadScript = `
                            <script>
                                (() => {
                                    const evtSource = new EventSource("/kire-livereload");
                                    evtSource.onmessage = (event) => {
                                        if (event.data === "reload") {
                                            window.location.reload();
                                        }
                                    };
                                })();
                            </script>
                        `;

                        if (notFoundHtml.includes("</body>")) {
                            notFoundHtml = notFoundHtml.replace("</body>", `${liveReloadScript}</body>`);
                        } else {
                            notFoundHtml += liveReloadScript;
                        }

                        res.end(notFoundHtml);
                        Logger.request(req.method!, url, 404, Date.now() - start);
                        return;
                    }
                } catch (e) {
                    // Ignore
                }

                const isNoise = url.includes("favicon.ico") || url.includes(".well-known") || url.includes(".map");
                res.statusCode = 404;
                res.end(`Not Found: ${req.url}`);
                if (!isNoise) Logger.request(req.method!, url, 404, Date.now() - start);
            }
        } catch (e: any) {
            res.statusCode = 500;
            res.end(renderErrorPage({
                error: e,
                req,
                files: [],
                kire: kireInstance!
            }));
            Logger.error(`500 ${req.url}`, e);
            Logger.request(req.method!, url, 500, Date.now() - start);
        }
    });

    server.listen(port, () => {
        Logger.success(`Server running at ${colors.brightWhite}http://localhost:${port}${colors.reset}`);
    });

    return new Promise(() => { });
}

// --- From: packages/ssg/src/logger.ts ---
// Cores ANSI para terminal
export const colors = {
	reset: "\x1b[0m",
	bright: "\x1b[1m",
	dim: "\x1b[2m",
	underscore: "\x1b[4m",

	// Cores de texto
	red: "\x1b[31m",
	green: "\x1b[32m",
	yellow: "\x1b[33m",
	blue: "\x1b[34m",
	magenta: "\x1b[35m",
	cyan: "\x1b[36m",
	white: "\x1b[37m",

	// Cores bright
	brightRed: "\x1b[91m",
	brightGreen: "\x1b[92m",
	brightYellow: "\x1b[93m",
	brightBlue: "\x1b[94m",
	brightMagenta: "\x1b[95m",
	brightCyan: "\x1b[96m",
	brightWhite: "\x1b[97m",
};

function getTimestamp(): string {
	const now = new Date();
	const h = now.getHours().toString().padStart(2, "0");
	const m = now.getMinutes().toString().padStart(2, "0");
	const s = now.getSeconds().toString().padStart(2, "0");
	return `${colors.dim}${h}:${m}:${s}${colors.reset}`;
}

function formatPrefix(level: string, color: string): string {
	return `${color}[${level}]${colors.reset}`;
}

const kirePrefix = `${colors.brightRed}[kire]${colors.reset}`;

export const Logger = {
	info: (message: string) => {
		console.log(
			`${getTimestamp()} ${kirePrefix} ${formatPrefix("INFO", colors.brightCyan)} ${message}`,
		);
	},

	success: (message: string) => {
		console.log(
			`${getTimestamp()} ${kirePrefix} ${formatPrefix("SUCCESS", colors.green)} ${message}`,
		);
	},

	warn: (message: string) => {
		console.warn(
			`${getTimestamp()} ${kirePrefix} ${formatPrefix("WARN", colors.brightYellow)} ${message}`,
		);
	},

	error: (message: string, error?: any) => {
		console.error(
			`${getTimestamp()} ${kirePrefix} ${formatPrefix("ERROR", colors.brightRed)} ${message}`,
		);
		if (error) {
			console.error(error);
		}
	},

	log: (message: string) => {
		console.log(`${getTimestamp()} ${kirePrefix} ${message}`);
	},

	request: (method: string, path: string, status: number, duration?: number) => {
		const methodColor =
			{
				GET: colors.brightGreen,
				POST: colors.brightBlue,
				PUT: colors.brightYellow,
				DELETE: colors.brightRed,
				PATCH: colors.brightMagenta,
				OPTIONS: colors.brightCyan,
			}[method] || colors.brightWhite;

		const statusColor =
			status >= 500
				? colors.brightRed
				: status >= 400
					? colors.brightYellow
					: status >= 300
						? colors.brightCyan
						: colors.brightGreen;

		const durationStr = duration
			? `${colors.dim}(${Math.round(duration)}ms)${colors.reset}`
			: "";

		console.log(
			`${getTimestamp()} ${kirePrefix} ${methodColor}${method.padEnd(7)}${colors.reset} ${colors.brightWhite}${path}${colors.reset} ${colors.dim}â†’${colors.reset} ${statusColor}${status}${colors.reset} ${durationStr}`,
		);
	},

	build: (path: string, type: "page" | "asset" | "gen" = "page") => {
		const icon = type === "page" ? "ðŸ“„" : type === "asset" ? "ðŸ“¦" : "âš¡";
		const typeColor =
			type === "page"
				? colors.brightWhite
				: type === "asset"
					? colors.cyan
					: colors.magenta;
		console.log(
			`${getTimestamp()} ${kirePrefix} ${colors.green}âœ“${colors.reset} ${icon} ${typeColor}${path}${colors.reset}`,
		);
	},
};


// --- From: packages/ssg/src/index.ts ---
import type { Kire, KirePlugin } from "kire";
import { type SsgOptions, type SsgState, setActiveKire, activeKire } from "./types";
import { trackFileAccess, getSsgState } from "./utils";
import { build } from "./build";
import { dev } from "./dev";

declare module "kire" {
	interface Kire {
		parseMarkdown?(content: string): Promise<string>;
	}
}

export const KireSsg: KirePlugin<SsgOptions> & {
	build: typeof build;
	dev: typeof dev;
	getFileAccessHistory: () => SsgState['fileAccessHistory'];
	getRouteCompilationChain: () => SsgState['routeCompilationChain'];
} = {
	name: "@kirejs/ssg",
	options: {},
	load(kire: Kire, opts) {
        setActiveKire(kire);

        const state: SsgState = {
            options: opts || {},
            dynamicRoutesMap: new Map(),
            fileAccessHistory: [],
            routeCompilationChain: new Map(),
            currentRoute: null
        };
        
		if (state.options.assetsPrefix) {
			state.options.assetsPrefix = state.options.assetsPrefix.replace(/^\//, "").replace(/\/$/, "");
		}

        const cache = kire.cached<SsgState>("@kirejs/ssg");
        cache.set("ROOT", state);

		trackFileAccess(kire);

		kire.$ctx('__ssg_register_routes', (routes: any[]) => {
            try {
                const ssgState = getSsgState(kire);
                if (ssgState.currentRoute) {
                    ssgState.dynamicRoutesMap.set(ssgState.currentRoute, routes);
                }
            } catch(e) {}
		});

		kire.directive({
			name: 'dynamicroutes',
			params: ['routes:expression'],
			onCall(compiler) {
				const expr = compiler.param('routes');
				compiler.raw(`$ctx.__ssg_register_routes(${expr});`);
			}
		});
	},

	build,
	dev,
	
	getFileAccessHistory() {
        if (!activeKire) return [];
        try {
            return getSsgState(activeKire).fileAccessHistory;
        } catch(e) { return []; }
	},
	
	getRouteCompilationChain() {
        if (!activeKire) return new Map();
        try {
            return getSsgState(activeKire).routeCompilationChain;
        } catch(e) { return new Map(); }
	}
};

export default KireSsg;

// --- From: packages/ssg/src/error-page.ts ---
import type { IncomingMessage } from "node:http";
import type { Kire } from "kire";

export interface ErrorPageParams {
  error: any;
  req: IncomingMessage;
  files: string[];
  kire: Kire;
}

function escapeHtml(input: string): string {
  return input
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

export function renderErrorPage(params: ErrorPageParams): string {
  const { error, req, files, kire } = params;

  const errorTitle = escapeHtml(String(error?.message || "Internal Server Error"));
  const stack = escapeHtml(String(error?.stack || ""));
  const generatedCode = escapeHtml(String(error?.kireGeneratedCode || ""));
  const codeFrame = escapeHtml(String(error?.codeFrame || ""));
  const url = escapeHtml(String(req?.url || "/"));
  const method = escapeHtml(String((req as any)?.method || "GET"));

  // Get compilation chain from Kire instance (if available)
  const compilationChain: string[] = (kire as any).$compilationChain || [];

  const hasCodeFrame = Boolean(codeFrame && codeFrame.trim().length > 0);
  const hasGeneratedCode = Boolean(generatedCode && generatedCode.trim().length > 0);

  return `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Error: ${errorTitle}</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@iconify/iconify@3.0/dist/iconify.min.js"></script>
  <script>
    // Optional: small theme adjustments (no custom CSS)
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: {
            mono: ["SFMono-Regular", "Consolas", "Liberation Mono", "Menlo", "monospace"],
            sans: ["-apple-system","BlinkMacSystemFont","Segoe UI","Roboto","sans-serif"]
          }
        }
      }
    };
  </script>
</head>

<body class="min-h-screen bg-zinc-900 text-slate-200 font-sans">
  <div class="mx-auto max-w-6xl px-5 py-8">
    <!-- Header -->
    <header class="relative mb-8 pl-10">
      <div class="absolute -left-10 -top-8 -z-10 select-none text-[160px] leading-none font-black text-red-500/10">500</div>

      <div class="flex items-center gap-2">
        <span class="text-xs font-semibold tracking-[0.2em] uppercase text-red-300/90">
          Kire Error
        </span>
        <span class="text-slate-500">â€¢</span>
        <span class="text-xs font-semibold tracking-[0.2em] uppercase text-slate-500">
          Internal Server Error
        </span>
      </div>

      <h1 class="mt-2 text-2xl sm:text-3xl font-bold text-white break-words">
        ${errorTitle}
      </h1>

      <div class="mt-3 flex flex-wrap items-center gap-2 text-sm">
        <span class="inline-flex items-center gap-2 rounded-md bg-sky-500/10 px-2.5 py-1 font-mono text-sky-300">
          <span class="text-sky-200/80">${method}</span>
          <span class="text-sky-300">${url}</span>
        </span>

        <span class="inline-flex items-center gap-2 rounded-md bg-slate-800 px-2.5 py-1 text-slate-300">
          <span class="text-slate-400">Cached:</span>
          <span class="font-semibold text-slate-200">${files.length}</span>
          <span class="text-slate-400">files</span>
        </span>

        <span class="inline-flex items-center gap-2 rounded-md bg-slate-800 px-2.5 py-1 text-slate-300">
          <span class="text-slate-400">Chain:</span>
          <span class="font-semibold text-slate-200">${compilationChain.length}</span>
          <span class="text-slate-400">steps</span>
        </span>
      </div>
    </header>

    <!-- Tabs -->
    <nav class="mb-6 flex flex-wrap gap-2 border-b border-slate-800 pb-3">
      <button data-tab="stack"
        class="tab-btn inline-flex items-center gap-2 rounded-md bg-sky-500/20 px-3 py-2 text-sm font-medium text-sky-300 transition hover:bg-slate-800 hover:text-slate-100">
        <span class="iconify" data-icon="mdi:bug-outline"></span>
        Stack Trace
      </button>

      <button data-tab="files"
        class="tab-btn inline-flex items-center gap-2 rounded-md bg-slate-800 px-3 py-2 text-sm font-medium text-slate-300 transition hover:bg-slate-700 hover:text-slate-100">
        <span class="iconify" data-icon="mdi:file-multiple-outline"></span>
        Cached Files <span class="rounded bg-slate-700 px-2 py-0.5 text-xs text-slate-200">${files.length}</span>
      </button>

      <button data-tab="chain"
        class="tab-btn inline-flex items-center gap-2 rounded-md bg-slate-800 px-3 py-2 text-sm font-medium text-slate-300 transition hover:bg-slate-700 hover:text-slate-100">
        <span class="iconify" data-icon="mdi:link-variant"></span>
        Compilation Chain
      </button>

      ${hasCodeFrame ? `
        <button data-tab="codeframe"
          class="tab-btn inline-flex items-center gap-2 rounded-md bg-slate-800 px-3 py-2 text-sm font-medium text-slate-300 transition hover:bg-slate-700 hover:text-slate-100">
          <span class="iconify" data-icon="mdi:code-braces"></span>
          Code Frame
        </button>
      ` : ""}

      ${hasGeneratedCode ? `
        <button data-tab="generated"
          class="tab-btn inline-flex items-center gap-2 rounded-md bg-slate-800 px-3 py-2 text-sm font-medium text-slate-300 transition hover:bg-slate-700 hover:text-slate-100">
          <span class="iconify" data-icon="mdi:code-json"></span>
          Generated Code
        </button>
      ` : ""}
    </nav>

    <!-- Layout -->
    <div class="grid gap-6 lg:grid-cols-3">
      <!-- Main panel -->
      <main class="lg:col-span-2 space-y-6">
        <!-- Stack -->
        <section data-tab-panel="stack" class="tab-panel space-y-3">
          <div class="flex items-center justify-between gap-3">
            <h2 class="text-xs font-semibold tracking-wider uppercase text-slate-400">Stack Trace</h2>

            <button type="button" data-copy-from="stack-pre"
              class="inline-flex items-center gap-2 rounded-md bg-sky-500/20 px-3 py-2 text-sm font-medium text-sky-300 transition hover:bg-sky-500/30">
              <span class="iconify" data-icon="mdi:content-copy"></span>
              Copy
            </button>
          </div>

          <pre id="stack-pre"
            class="max-h-[70vh] overflow-auto rounded-lg border border-slate-800 bg-slate-950 p-4 font-mono text-xs sm:text-sm leading-relaxed whitespace-pre-wrap break-words">${stack}</pre>
        </section>

        <!-- Code Frame -->
        ${hasCodeFrame ? `
        <section data-tab-panel="codeframe" class="tab-panel hidden space-y-3">
          <div class="flex items-center justify-between gap-3">
            <h2 class="text-xs font-semibold tracking-wider uppercase text-slate-400">Code Frame</h2>

            <button type="button" data-copy-from="codeframe-pre"
              class="inline-flex items-center gap-2 rounded-md bg-sky-500/20 px-3 py-2 text-sm font-medium text-sky-300 transition hover:bg-sky-500/30">
              <span class="iconify" data-icon="mdi:content-copy"></span>
              Copy
            </button>
          </div>

          <pre id="codeframe-pre"
            class="max-h-[70vh] overflow-auto rounded-lg border border-red-500/30 bg-red-500/10 p-4 font-mono text-xs sm:text-sm leading-relaxed whitespace-pre-wrap break-words text-red-200">${codeFrame}</pre>
        </section>
        ` : ""}

        <!-- Generated -->
        ${hasGeneratedCode ? `
        <section data-tab-panel="generated" class="tab-panel hidden space-y-3">
          <div class="flex items-center justify-between gap-3">
            <h2 class="text-xs font-semibold tracking-wider uppercase text-slate-400">Generated Code</h2>

            <button type="button" data-copy-from="generated-pre"
              class="inline-flex items-center gap-2 rounded-md bg-sky-500/20 px-3 py-2 text-sm font-medium text-sky-300 transition hover:bg-sky-500/30">
              <span class="iconify" data-icon="mdi:content-copy"></span>
              Copy
            </button>
          </div>

          <pre id="generated-pre"
            class="max-h-[70vh] overflow-auto rounded-lg border border-slate-800 bg-slate-950 p-4 font-mono text-xs leading-relaxed whitespace-pre text-emerald-200">${generatedCode}</pre>
        </section>
        ` : ""}

        <!-- Chain -->
        <section data-tab-panel="chain" class="tab-panel hidden space-y-3">
          <div class="flex items-center justify-between gap-3">
            <h2 class="text-xs font-semibold tracking-wider uppercase text-slate-400">Compilation Chain</h2>

            <button type="button" data-copy-chain="1"
              class="inline-flex items-center gap-2 rounded-md bg-slate-800 px-3 py-2 text-sm font-medium text-slate-200 transition hover:bg-slate-700">
              <span class="iconify" data-icon="mdi:content-copy"></span>
              Copy list
            </button>
          </div>

          <div class="rounded-lg border border-slate-800 bg-slate-950 p-3">
            ${
              compilationChain.length > 0
                ? compilationChain
                    .map((file: string, i: number) => {
                      const safeFile = escapeHtml(String(file));
                      const isFirst = i === 0;
                      const isLast = i === compilationChain.length - 1;

                      const accent = isFirst
                        ? "border-red-400/60 bg-red-500/5"
                        : isLast
                          ? "border-rose-300/60 bg-rose-500/5"
                          : "border-sky-400/50 bg-sky-500/5";

                      const badge = isFirst
                        ? `<span class="ml-2 rounded bg-red-500/15 px-2 py-0.5 text-xs text-red-200">Entry</span>`
                        : isLast
                          ? `<span class="ml-2 rounded bg-rose-500/15 px-2 py-0.5 text-xs text-rose-200">Error</span>`
                          : "";

                      return `
                        <div class="mb-2 last:mb-0 rounded-md border-l-4 ${accent} px-3 py-2">
                          <div class="flex items-start gap-3">
                            <span class="mt-0.5 inline-flex h-6 w-6 items-center justify-center rounded-full bg-slate-800 text-xs text-slate-200">${i + 1}</span>
                            <div class="min-w-0">
                              <div class="font-mono text-sm text-slate-100 break-words">${safeFile}${badge}</div>
                            </div>
                          </div>
                        </div>
                      `;
                    })
                    .join("")
                : `<div class="px-3 py-10 text-center text-slate-400">No compilation chain available.</div>`
            }
          </div>
        </section>

        <!-- Files -->
        <section data-tab-panel="files" class="tab-panel hidden space-y-3">
          <div class="flex items-center justify-between gap-3">
            <h2 class="text-xs font-semibold tracking-wider uppercase text-slate-400">
              Cached Files (${files.length})
            </h2>

            <button type="button" data-copy-files="1"
              class="inline-flex items-center gap-2 rounded-md bg-slate-800 px-3 py-2 text-sm font-medium text-slate-200 transition hover:bg-slate-700">
              <span class="iconify" data-icon="mdi:content-copy"></span>
              Copy list
            </button>
          </div>

          <div class="rounded-lg border border-slate-800 bg-slate-950">
            <div class="max-h-[70vh] overflow-auto p-2">
              ${
                files.length
                  ? files
                      .map(
                        (f) => `
                          <div class="rounded-md px-3 py-2 font-mono text-xs sm:text-sm text-slate-200 hover:bg-slate-800 break-words">
                            ${escapeHtml(String(f))}
                          </div>
                        `
                      )
                      .join("")
                  : `<div class="px-3 py-10 text-center text-slate-500">No files in cache.</div>`
              }
            </div>
            <div class="border-t border-slate-800 px-4 py-3 text-sm text-slate-400">
              ${files.length} files cached for hot reload.
            </div>
          </div>
        </section>
      </main>

      <!-- Side panel -->
      <aside class="space-y-6">
        <section class="rounded-lg border border-slate-800 bg-slate-950 p-4">
          <h3 class="text-xs font-semibold tracking-wider uppercase text-slate-400">Quick Actions</h3>

          <div class="mt-3 grid gap-2">
            <button type="button" data-action="reload"
              class="inline-flex items-center justify-center gap-2 rounded-md bg-sky-500/20 px-3 py-2 text-sm font-medium text-sky-300 transition hover:bg-sky-500/30">
              <span class="iconify" data-icon="mdi:reload"></span>
              Reload Page
            </button>

            <button type="button" data-action="copy-text-report"
              class="inline-flex items-center justify-center gap-2 rounded-md bg-slate-800 px-3 py-2 text-sm font-medium text-slate-200 transition hover:bg-slate-700">
              <span class="iconify" data-icon="mdi:file-document-outline"></span>
              Copy Text Report
            </button>

            <button type="button" data-action="copy-html"
              class="inline-flex items-center justify-center gap-2 rounded-md bg-slate-800 px-3 py-2 text-sm font-medium text-slate-200 transition hover:bg-slate-700">
              <span class="iconify" data-icon="mdi:code-tags"></span>
              Copy HTML
            </button>

            <button type="button" data-action="back"
              class="inline-flex items-center justify-center gap-2 rounded-md bg-slate-800 px-3 py-2 text-sm font-medium text-slate-200 transition hover:bg-slate-700">
              <span class="iconify" data-icon="mdi:arrow-left"></span>
              Back
            </button>
          </div>
        </section>

        <section class="rounded-lg border border-slate-800 bg-slate-950 p-4">
          <div class="flex items-center justify-between gap-3">
            <h3 class="text-xs font-semibold tracking-wider uppercase text-slate-400">Kire Dev Server</h3>
            <span class="rounded-full bg-red-500/20 px-2 py-0.5 text-xs text-red-300">v1.0</span>
          </div>

          <div class="mt-3 text-sm text-slate-400">
            <p class="mb-2">This error page is generated by the Kire development server.</p>
            <p>Use tabs to navigate between error details and system information.</p>
          </div>
        </section>
      </aside>
    </div>
  </div>

  <!-- Toast -->
  <div id="toast"
    class="pointer-events-none fixed bottom-4 right-4 hidden max-w-sm rounded-lg border border-slate-800 bg-slate-950/95 px-4 py-3 text-sm text-slate-100 shadow-lg">
    <div class="flex items-center gap-2">
      <span class="iconify text-green-400" data-icon="mdi:check-circle-outline"></span>
      <span id="toast-msg">Copied to clipboard!</span>
    </div>
  </div>

  <script>
    (function () {
      const btns = Array.from(document.querySelectorAll(".tab-btn"));
      const panels = Array.from(document.querySelectorAll(".tab-panel"));

      function setActiveTab(name) {
        // Panels
        panels.forEach(p => {
          const isTarget = p.getAttribute("data-tab-panel") === name;
          p.classList.toggle("hidden", !isTarget);
        });

        // Buttons
        btns.forEach(b => {
          const isTarget = b.getAttribute("data-tab") === name;
          b.classList.toggle("bg-sky-500/20", isTarget);
          b.classList.toggle("text-sky-300", isTarget);
          b.classList.toggle("hover:bg-slate-800", isTarget);

          b.classList.toggle("bg-slate-800", !isTarget);
          b.classList.toggle("text-slate-300", !isTarget);
          b.classList.toggle("hover:bg-slate-700", !isTarget);
        });
      }

      btns.forEach(b => {
        b.addEventListener("click", () => setActiveTab(b.getAttribute("data-tab")));
      });

      // default tab
      setActiveTab("stack");

      // Toast
      let toastTimer = null;
      function toast(msg) {
        const el = document.getElementById("toast");
        const msgEl = document.getElementById("toast-msg");
        if (!el || !msgEl) return;

        msgEl.textContent = msg || "Copied to clipboard!";
        el.classList.remove("hidden");

        if (toastTimer) clearTimeout(toastTimer);
        toastTimer = setTimeout(() => el.classList.add("hidden"), 1800);
      }

      // Generate comprehensive text report
      function generateTextReport() {
        const now = new Date();
        const report = [
          "=".repeat(60),
          "KIRE ERROR REPORT",
          "=".repeat(60),
          "Timestamp: " + now.toISOString(),
          "Error: " + ${JSON.stringify(errorTitle)},
          "URL: " + ${JSON.stringify(method)} + " " + ${JSON.stringify(url)},
          "",
          "STACK TRACE:",
          ${JSON.stringify(stack)},
          "",
          "COMPILATION CHAIN (" + ${JSON.stringify(compilationChain.length)} + " steps):"
        ];

        ${JSON.stringify(compilationChain)}.forEach((file, i) => {
          const prefix = i === 0 ? "[Entry] " : i === ${JSON.stringify(compilationChain)}.length - 1 ? "[Error] " : "";
          report.push((i + 1) + ". " + prefix + file);
        });

        report.push(
          "",
          "CACHED FILES (" + ${JSON.stringify(files.length)} + "):"
        );

        ${JSON.stringify(files)}.forEach(f => {
          report.push("â€¢ " + f);
        });

        report.push(
          "",
          "CODE FRAME:",
          ${JSON.stringify(codeFrame || "No code frame available")},
          "",
          "GENERATED CODE:",
          ${JSON.stringify(generatedCode || "No generated code available")},
          "=".repeat(60),
          "End of Report",
          "=".repeat(60)
        );

        return report.join("\\n");
      }

      // Clipboard helpers
      async function copyText(text) {
        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(text);
            toast("Copied to clipboard!");
            return true;
          }
        } catch (_) {}

        // fallback
        try {
          const ta = document.createElement("textarea");
          ta.value = text;
          ta.setAttribute("readonly", "true");
          ta.style.position = "fixed";
          ta.style.left = "-9999px";
          document.body.appendChild(ta);
          ta.select();
          document.execCommand("copy");
          document.body.removeChild(ta);
          toast("Copied to clipboard!");
          return true;
        } catch (err) {
          console.error("Error copying:", err);
          toast("Failed to copy");
          return false;
        }
      }

      // Copy buttons (from element)
      document.querySelectorAll("[data-copy-from]").forEach(btn => {
        btn.addEventListener("click", () => {
          const id = btn.getAttribute("data-copy-from");
          const el = document.getElementById(id);
          const text = el ? el.innerText : "";
          copyText(text);
        });
      });

      // Copy chain/files as list
      const chain = ${JSON.stringify(compilationChain)};
      const files = ${JSON.stringify(files)};

      const chainBtn = document.querySelector("[data-copy-chain]");
      if (chainBtn) {
        chainBtn.addEventListener("click", () => copyText(chain.join("\\n")));
      }

      const filesBtn = document.querySelector("[data-copy-files]");
      if (filesBtn) {
        filesBtn.addEventListener("click", () => copyText(files.join("\\n")));
      }

      // Quick actions
      document.querySelectorAll("[data-action]").forEach(btn => {
        btn.addEventListener("click", () => {
          const action = btn.getAttribute("data-action");
          if (action === "reload") window.location.reload();
          if (action === "copy-text-report") copyText(generateTextReport());
          if (action === "copy-html") copyText(document.documentElement.outerHTML);
          if (action === "back") history.back();
        });
      });

      // Auto-reload (dev)
      if (typeof EventSource !== "undefined") {
        try {
          const evtSource = new EventSource("/kire-livereload");
          evtSource.onmessage = (e) => {
            if (e.data === "reload") {
              console.log("[Kire] Reloading due to file changes...");
              window.location.reload();
            }
          };
        } catch (e) {
          // ignore
        }
      }
    })();
  </script>
</body>
</html>
  `;
}

// --- From: packages/ssg/src/build.ts ---
import { mkdir, readdir, writeFile } from "node:fs/promises";
import { dirname, join, relative, resolve } from "node:path";
import { glob } from "glob";
import type { KireAsset } from "@kirejs/assets";
import { Logger, colors } from "./logger";
import { getFiles, getSsgState } from "./utils";
import { activeKire, type BuildOptions, type SsgBuilder } from "./types";

export async function build(opts: BuildOptions) {
    const kireInstance = activeKire;
    if (!kireInstance)
        throw new Error("KireSsg plugin not registered or Kire instance not ready.");

    const state = getSsgState(kireInstance);
    const pluginOptions = state.options;
    const dynamicRoutesMap = state.dynamicRoutesMap;

    const outDir = resolve(opts.out);
    const rootDir = resolve(kireInstance.root);
    const routesDir = resolve(rootDir, pluginOptions.routes || ".");
    const assetsPrefix = pluginOptions.assetsPrefix || "_kire";

    Logger.info(`Building from ${colors.brightWhite}${routesDir}${colors.reset} to ${colors.brightWhite}${outDir}${colors.reset}...`);

    await mkdir(outDir, { recursive: true });

    // Copy public folder
    if (pluginOptions.public) {
        const publicDir = resolve(rootDir, pluginOptions.public);
        try {
            const cp = async (src: string, dest: string) => {
                const stats = await import("node:fs/promises").then(fs => fs.stat(src));
                if (stats.isDirectory()) {
                    await mkdir(dest, { recursive: true });
                    const entries = await readdir(src);
                    for (const entry of entries) {
                        await cp(join(src, entry), join(dest, entry));
                    }
                } else {
                    await import("node:fs/promises").then(fs => fs.copyFile(src, dest));
                }
            };
            await cp(publicDir, outDir);
            Logger.success(`Public assets copied from ${pluginOptions.public}`);
        } catch (e) {
            Logger.warn(`Could not copy public directory: ${e}`);
        }
    }

    const allFiles = await getFiles(routesDir);
    const ext = kireInstance.extension.startsWith(".")
        ? kireInstance.extension
        : `.${kireInstance.extension}`;

    const templateFiles = allFiles.filter((f) => f.endsWith(ext));
    const generatedRoutes: string[] = [];

    for (const file of templateFiles) {
        const relativePath = relative(routesDir, file);
        if (relativePath.split("/").some((p) => p.startsWith("_"))) continue;

        const kireResolvePath = relative(rootDir, file);
        const hasParamInName = relativePath.includes("[") && relativePath.includes("]");

        try {
            state.fileAccessHistory.length = 0;
            state.routeCompilationChain.clear();
            
            // Initial Render
            const html = await kireInstance.view(kireResolvePath, { currentPath: "", $params: {} });
            const declaredRoutes = dynamicRoutesMap.get(kireResolvePath);

            if (hasParamInName) {
                if (declaredRoutes && Array.isArray(declaredRoutes)) {
                    const match = relativePath.match(/\[([^\]]+)\]/);
                    const paramName = match ? match[1] : null;

                    if (paramName) {
                        for (const item of declaredRoutes) {
                            let paramValue = typeof item === 'object' ? (item[paramName] || item.name || item.id || item.package) : item;
                            if (!paramValue) continue;

                            if (paramName === 'package' && typeof paramValue === 'string') {
                                paramValue = paramValue.replace('@kirejs/', '');
                            }

                            const params = { [paramName]: paramValue };
                            const pageHtml = await kireInstance.view(kireResolvePath, { $params: params });
                            
                            const nameWithoutExt = relativePath.slice(0, -ext.length);
                            const baseRoute = nameWithoutExt.replace(`.[${paramName}]`, "").replace(`[${paramName}]`, "");
                            const htmlOutPath = join(baseRoute, paramValue, "index.html");
                            const outPath = join(outDir, htmlOutPath);

                            await mkdir(dirname(outPath), { recursive: true });
                            await writeFile(outPath, pageHtml);
                            
                            generatedRoutes.push("/" + join(baseRoute, paramValue).replace(/\\/g, '/'));
                            Logger.build(htmlOutPath, "gen");
                        }
                    }
                } else {
                    Logger.warn(`Dynamic template ${relativePath} did not declare routes via @dynamicroutes.`);
                }
                continue;
            }

            const markerRegex = /<!-- KIRE_GEN:(.*?) -->/;
            const match = html.match(markerRegex);

            if (match) {
                const globPattern = match[1];
                Logger.info(`Detected Generator in ${relativePath} for '${globPattern}'`);
                const mdFiles = await glob(globPattern!, { cwd: rootDir });

                for (const mdFile of mdFiles) {
                    const mdRelative = String(mdFile);
                    const pageHtml = await kireInstance.view(kireResolvePath, { currentPath: mdRelative });
                    const finalHtml = pageHtml.replace(match[0], "");
                    const cleanName = mdRelative.replace(/\.(md|markdown)$/, "");
                    const htmlOutPath = join(cleanName, "index.html");
                    const fullOutPath = join(outDir, htmlOutPath);
                    
                    await mkdir(dirname(fullOutPath), { recursive: true });
                    await writeFile(fullOutPath, finalHtml);
                    
                    generatedRoutes.push("/" + cleanName);
                    Logger.build(htmlOutPath, "gen");
                }
            } else {
                let htmlOutPath = "";
                const nameWithoutExt = relativePath.slice(0, -ext.length);
                
                if (nameWithoutExt === "index" || nameWithoutExt.endsWith("/index")) {
                    htmlOutPath = nameWithoutExt + ".html";
                } else {
                    htmlOutPath = join(nameWithoutExt, "index.html");
                }

                const outPath = join(outDir, htmlOutPath);
                await mkdir(dirname(outPath), { recursive: true });
                await writeFile(outPath, html);
                
                const routeUrl = htmlOutPath.replace(/\/index\.html$/, "").replace(/\.html$/, "");
                generatedRoutes.push(routeUrl === "index" ? "/" : "/" + routeUrl);
                
                Logger.build(htmlOutPath, "page");
            }
        } catch (e: any) {
            Logger.error(`Failed to render ${relativePath}: ${e.message}`);
        }
    }

    const assetsCache = kireInstance.cached<KireAsset>("@kirejs/assets");
    const entries = Array.from(assetsCache.entries());

    if (entries.length > 0) {
        const assetsDir = join(outDir, assetsPrefix);
        await mkdir(assetsDir, { recursive: true });

        for (const [hash, asset] of entries) {
            const filename = `${hash}.${asset.type === "css" ? "css" : asset.type === "mjs" ? "mjs" : "js"}`;
            await writeFile(join(assetsDir, filename), asset.content);
            Logger.build(`${assetsPrefix}/${filename}`, "asset");
        }
    }

    if (pluginOptions.poshandler) {
        Logger.info("Running post-build handler...");
        
        const builder: SsgBuilder = {
            routes: generatedRoutes,
            add: async (path: string, content: string) => {
                const fullPath = join(outDir, path);
                await mkdir(dirname(fullPath), { recursive: true });
                await writeFile(fullPath, content);
                Logger.success(`Added: ${path}`);
            },
            rem: async (path: string) => {
                const fullPath = join(outDir, path);
                try {
                    await import("node:fs/promises").then(fs => fs.rm(fullPath, { force: true, recursive: true }));
                    Logger.info(`Removed: ${path}`);
                } catch (e) {
                    Logger.warn(`Failed to remove ${path}: ${e}`);
                }
            }
        };

        await pluginOptions.poshandler(builder);
    }

    Logger.success("Build complete.");
}


